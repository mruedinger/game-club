---
import AppHeader from "../components/AppHeader.astro";
import AppFooter from "../components/AppFooter.astro";
import { getRuntimeEnv, readSession } from "../lib/auth";
import "../styles/base.css";

type Game = {
	id: number;
	title: string;
	status: "backlog" | "current" | "played";
	poll_eligible?: number | null;
	is_mine?: number;
	tags_json?: string;
	played_month?: string;
	cover_art_url?: string;
	itad_boxart_url?: string;
	description?: string;
	submitted_by_name?: string;
	submitted_by_alias?: string;
	steam_app_id?: number;
	itad_slug?: string;
	current_price_cents?: number;
	best_price_cents?: number;
	time_to_beat_minutes?: number;
	is_favorite?: number;
	rating_count?: number;
	rating_average?: number;
	my_rating?: number;
};

const env = getRuntimeEnv(Astro.locals.runtime?.env);
const session = await readSession(Astro.request, env);
const initialUser = session
	? {
			email: session.email,
			name: session.name,
			alias: session.alias,
			picture: session.picture,
			role: session.role
		}
	: null;

const [pollResponse, settingsResponse, gamesResponse] = await Promise.all([
	fetch(new URL("/api/polls", Astro.url), {
		headers: Astro.request.headers
	}),
	fetch(new URL("/api/site-settings", Astro.url), {
		headers: Astro.request.headers
	}),
	fetch(new URL("/api/games", Astro.url), {
		headers: Astro.request.headers
	})
]);

const pollState = pollResponse.ok ? await pollResponse.json() : null;
const settingsPayload = settingsResponse.ok ? await settingsResponse.json() : { next_meeting: null };
const nextMeeting = typeof settingsPayload.next_meeting === "string" ? settingsPayload.next_meeting : null;
const gamesPayload = gamesResponse.ok
	? await gamesResponse.json()
	: { backlog: [], current: null, played: [] };
const backlogGames = gamesPayload.backlog as Game[];
const playedGames = gamesPayload.played as Game[];
const currentGame = Array.isArray(gamesPayload.current) ? ((gamesPayload.current[0] as Game | undefined) ?? null) : null;

function formatUsd(value?: number) {
	if (typeof value !== "number") return "TBD";
	return new Intl.NumberFormat("en-US", {
		style: "currency",
		currency: "USD"
	}).format(value / 100);
}

function firstName(value?: string) {
	if (!value) return "";
	return value.trim().split(/\s+/)[0] || "";
}

function getSubmitterLabel(game?: Game | null) {
	if (!game) return "Submitted by a member";
	const submitter = getSubmitter(game);
	return submitter ? `Submitted by ${submitter}` : "Submitted by a member";
}

function formatTtbHours(minutes?: number) {
	if (typeof minutes !== "number" || minutes <= 0) return null;
	const hours = minutes / 60;
	const rounded = Math.round(hours * 10) / 10;
	const text = rounded % 1 === 0 ? String(Math.trunc(rounded)) : String(rounded);
	return `${text} Hours`;
}

function formatTimeToBeat(minutes?: number | null) {
	if (!minutes && minutes !== 0) return "-";
	const hours = Math.floor(minutes / 60);
	const mins = Math.round(minutes % 60);
	return `${String(hours).padStart(2, "0")}:${String(mins).padStart(2, "0")}`;
}

function getSubmitter(game: Game) {
	return game.submitted_by_alias || firstName(game.submitted_by_name) || "Member";
}

function formatTags(tagsJson?: string) {
	if (!tagsJson) return "Tags coming soon";
	try {
		const parsed = JSON.parse(tagsJson);
		if (!Array.isArray(parsed)) return "Tags coming soon";
		const tags = parsed
			.filter((tag): tag is string => typeof tag === "string")
			.map((tag) => tag.trim())
			.filter(Boolean);
		return tags.length > 0 ? tags.join(" · ") : "Tags coming soon";
	} catch {
		return "Tags coming soon";
	}
}

function formatStarRow(value?: number | null) {
	if (typeof value !== "number" || Number.isNaN(value) || value <= 0) {
		return "☆☆☆☆☆";
	}
	const clamped = Math.max(0, Math.min(5, Math.round(value)));
	return `${"★".repeat(clamped)}${"☆".repeat(5 - clamped)}`;
}

function formatRatingSummaryText(average?: number | null, count?: number | null) {
	const total = typeof count === "number" ? count : 0;
	if (total <= 0 || typeof average !== "number" || Number.isNaN(average)) {
		return "No ratings yet";
	}
	return `${formatStarRow(average)} ${average.toFixed(1)} (${total})`;
}

const meetingLabel = nextMeeting ? "Next meeting: Loading..." : "Next meeting: TBD";
---

<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<meta name="generator" content={Astro.generator} />
		<meta
			name="description"
			content="Video game club."
		/>
		<title>Game Club</title>
		</head>
		<body>
			<AppHeader initialUser={initialUser} />

		<main>
			<div class="container">
			<section class="hero centered">
				<div class="hero-text">
					<p class="eyebrow">Monthly(ish) Video Game Club</p>
						<h1>Dusting off the library one month at a time</h1>
					<p class="lead" id="next-meeting" data-iso={nextMeeting || ""}>
						{meetingLabel}
					</p>
				</div>
			</section>

				<section class="section current-game two-column-grid">
				<div>
					{currentGame ? (
						<div
							class="card current-game-card"
							data-id={currentGame.id}
							data-title={currentGame.title}
							data-rating-count={typeof currentGame.rating_count === "number" ? String(currentGame.rating_count) : "0"}
							data-rating-average={typeof currentGame.rating_average === "number" ? String(currentGame.rating_average) : ""}
							data-my-rating={typeof currentGame.my_rating === "number" ? String(currentGame.my_rating) : ""}
						>
							<div class="game-cover">
								{currentGame.cover_art_url ? (
									<img
										src={currentGame.cover_art_url}
										alt={`${currentGame.title} cover art`}
										loading="lazy"
									/>
								) : (
									<div class="cover-placeholder">Cover coming soon</div>
								)}
							</div>
								<h4 class="game-title">Current Game: {currentGame.title}</h4>
									{(() => {
										const tags = formatTags(currentGame.tags_json);
										const ttb = formatTtbHours(currentGame.time_to_beat_minutes);
										return (
											<p class="meta-line tight">
											{ttb ? `${ttb} | ${tags}` : tags}
										</p>
									);
								})()}
							<p class="current-game-description">
								{currentGame.description || "Description coming soon."}
							</p>
							<div class="game-detail-links">
								{currentGame.steam_app_id ? (
									<a
										class="ghost small-pill"
										target="_blank"
										rel="noreferrer"
										title="View on Steam"
										href={`https://store.steampowered.com/app/${currentGame.steam_app_id}`}
									>
										Steam
									</a>
								) : null}
								<a
									class="ghost small-pill"
									target="_blank"
									rel="noreferrer"
									title="View on HowLongToBeat"
									href={`https://howlongtobeat.com/?q=${encodeURIComponent(currentGame.title)}`}
								>
									HLTB
								</a>
								{currentGame.itad_slug ? (
									<a
										class="ghost small-pill"
										target="_blank"
										rel="noreferrer"
										title="View on IsThereAnyDeal"
										href={`https://isthereanydeal.com/game/${currentGame.itad_slug}/info/`}
									>
									ITAD
								</a>
							) : null}
							</div>
							<p class="meta-line">
								Current low: {formatUsd(currentGame.current_price_cents)} · Historical
								low: {formatUsd(currentGame.best_price_cents)}
							</p>
							<div class="game-rating-wrap current-game-rating-wrap" data-game-id={currentGame.id}>
								<p
									class="muted small game-rating-summary"
									data-game-id={currentGame.id}
									data-rating-count={typeof currentGame.rating_count === "number" ? String(currentGame.rating_count) : "0"}
									data-rating-average={typeof currentGame.rating_average === "number" ? String(currentGame.rating_average) : ""}
									tabindex="0"
								>
									Member Rating: {formatRatingSummaryText(currentGame.rating_average, currentGame.rating_count)}
								</p>
								<div class="game-rating-hover">
									<ul class="game-rating-hover-list" data-game-id={currentGame.id}></ul>
								</div>
							</div>
							<p class="muted small">{getSubmitterLabel(currentGame)}</p>
							<button
								class="ghost small-pill rate-current-game hidden"
								type="button"
								data-game-id={currentGame.id}
								data-game-title={currentGame.title}
							>
								Rate
							</button>
						</div>
					) : (
						<p class="muted">No current game set yet.</p>
					)}
				</div>
				<div class="card poll-summary" id="poll-summary">
					<div class="poll-summary-header">
						<div class="poll-header">
							<h3>Poll</h3>
							<span class="poll-status-text hidden" id="poll-chip">Inactive</span>
						</div>
						<div class="poll-summary-actions">
							<button class="ghost hidden" type="button" data-action="open-eligibility">
								Set eligibility
							</button>
							<button class="cta" type="button" data-action="start-poll">Start a poll</button>
						</div>
					</div>
					<p class="muted" id="poll-status">Loading poll status...</p>
					<form class="poll-vote-form hidden" id="poll-vote-form">
						<div class="poll-vote-list">
							<div class="field">
								<label for="poll-choice-1">First choice</label>
								<select id="poll-choice-1" name="choice1">
									<option value="">Select a game</option>
								</select>
							</div>
							<div class="field">
								<label for="poll-choice-2">Second choice</label>
								<select id="poll-choice-2" name="choice2">
									<option value="">Optional</option>
								</select>
							</div>
							<div class="field">
								<label for="poll-choice-3">Third choice</label>
								<select id="poll-choice-3" name="choice3">
									<option value="">Optional</option>
								</select>
							</div>
						</div>
						<p class="poll-error hidden" id="poll-error" role="alert"></p>
						<div class="poll-vote-actions">
							<button class="cta" type="submit">Vote</button>
						</div>
					</form>
					<div class="poll-results" id="poll-results"></div>
					<p class="muted small" id="poll-meta"></p>
					<div class="poll-footer-actions">
						<button class="ghost danger hidden" type="button" data-action="close-poll">
							Close poll
						</button>
					</div>
					</div>
				</section>

					<section class="section">
						<div class="section-head">
							<h2>Backlog</h2>
							<button class="cta add-game hidden" type="button">Add a game</button>
						</div>
						<p class="form-error hidden" id="backlog-feedback" role="alert"></p>
						<div class="table-wrapper backlog-table-wrapper">
						<table class="games-table">
							<thead>
								<tr>
									<th data-sort="favorite" class="sortable favorite-header">Favorite</th>
									<th data-sort="title" class="sortable">Title</th>
									<th data-sort="submitter" class="sortable">Submitter</th>
									<th data-sort="ttb" class="sortable">Time to beat</th>
									<th data-sort="current" class="sortable">Current low</th>
								</tr>
							</thead>
							<tbody>
								{backlogGames.map((game) => (
										<tr
											class:list={[
												"game-row",
												"clickable-row",
												game.poll_eligible === 1 ? "" : "is-poll-ineligible"
											]}
											data-id={game.id}
											data-title={game.title}
											data-title-sort={game.title.toLowerCase()}
											data-submitter={getSubmitter(game)}
											data-submitter-sort={getSubmitter(game).toLowerCase()}
											data-ttb={
												typeof game.time_to_beat_minutes === "number"
													? String(game.time_to_beat_minutes)
													: ""
											}
											data-ttb-minutes={
												typeof game.time_to_beat_minutes === "number"
													? String(game.time_to_beat_minutes)
													: ""
											}
											data-current-price={
												typeof game.current_price_cents === "number"
													? String(game.current_price_cents)
													: ""
											}
											data-best-price={
												typeof game.best_price_cents === "number"
													? String(game.best_price_cents)
													: ""
											}
											data-tags={game.tags_json || ""}
											data-description={game.description || ""}
											data-cover={game.cover_art_url || ""}
											data-submitted-name={game.submitted_by_name || ""}
											data-submitted-alias={game.submitted_by_alias || ""}
											data-steam-app-id={game.steam_app_id ? String(game.steam_app_id) : ""}
											data-itad-slug={game.itad_slug || ""}
											data-status={game.status}
											data-favorite={game.is_favorite ? "1" : "0"}
											data-poll-eligible={game.poll_eligible === 1 ? "1" : "0"}
											data-is-mine={game.is_mine ? "1" : "0"}
											data-rating-count={typeof game.rating_count === "number" ? String(game.rating_count) : "0"}
											data-rating-average={
												typeof game.rating_average === "number"
													? String(game.rating_average)
													: ""
											}
											data-my-rating={typeof game.my_rating === "number" ? String(game.my_rating) : ""}
										>
										<td class="favorite-cell">
											<button
												class:list={["ghost", "icon-button", "favorite-toggle", game.is_favorite ? "is-favorite" : ""]}
												type="button"
												data-game-id={game.id}
												data-favorite={game.is_favorite ? "1" : "0"}
												aria-label={game.is_favorite ? "Remove from favorites" : "Add to favorites"}
												title={game.is_favorite ? "Remove from favorites" : "Add to favorites"}
												aria-pressed={game.is_favorite ? "true" : "false"}
											>
												<span class="favorite-icon" aria-hidden="true">{game.is_favorite ? "♥" : "♡"}</span>
											</button>
										</td>
										<td>
											<div class="game-title-cell">
												<div class="game-icon">
													{game.itad_boxart_url || game.cover_art_url ? (
														<img src={game.itad_boxart_url || game.cover_art_url} alt="" loading="lazy" />
													) : (
														<span class="cover-placeholder">-</span>
													)}
												</div>
												<span class="game-title">{game.title}</span>
											</div>
										</td>
										<td class="muted">{getSubmitter(game)}</td>
										<td class="muted">{formatTimeToBeat(game.time_to_beat_minutes)}</td>
										<td class="muted">{formatUsd(game.current_price_cents)}</td>
									</tr>
								))}
							</tbody>
						</table>
					</div>
					<div class="row-tooltip" role="tooltip" aria-hidden="true">
						<div class="tooltip-description"></div>
						<div class="tooltip-tags"></div>
					</div>
				</section>

				<section class="section">
					<div class="section-head">
						<h2>Played</h2>
					</div>
					<div class="games-grid">
							{playedGames.map((game, index) => (
								<article
									class="game-card"
									style={`animation-delay: ${index * 70}ms`}
									data-id={game.id}
									data-title={game.title}
									data-tags={game.tags_json || ""}
									data-description={game.description || ""}
									data-cover={game.cover_art_url || ""}
									data-submitted-name={game.submitted_by_name || ""}
									data-submitted-alias={game.submitted_by_alias || ""}
									data-steam-app-id={game.steam_app_id ? String(game.steam_app_id) : ""}
									data-itad-slug={game.itad_slug || ""}
									data-current-price={
										typeof game.current_price_cents === "number"
											? String(game.current_price_cents)
										: ""
								}
								data-ttb-minutes={
									typeof game.time_to_beat_minutes === "number"
										? String(game.time_to_beat_minutes)
										: ""
								}
								data-best-price={
									typeof game.best_price_cents === "number"
										? String(game.best_price_cents)
										: ""
								}
								data-status={game.status}
								data-favorite={game.is_favorite ? "1" : "0"}
								data-rating-count={typeof game.rating_count === "number" ? String(game.rating_count) : "0"}
								data-rating-average={
									typeof game.rating_average === "number"
										? String(game.rating_average)
										: ""
								}
								data-my-rating={typeof game.my_rating === "number" ? String(game.my_rating) : ""}
							>
								<h3>{game.title}</h3>
								<div class="game-cover">
									{game.cover_art_url ? (
										<img
											src={game.cover_art_url}
											alt={`${game.title} cover art`}
											loading="lazy"
										/>
									) : (
										<div class="cover-placeholder">Cover coming soon</div>
									)}
									</div>
									<p class="muted">
										{formatTags(game.tags_json)}
									</p>
									<div class="game-rating-wrap" data-game-id={game.id}>
										<p
											class="muted small game-rating-summary"
											data-game-id={game.id}
											data-rating-count={typeof game.rating_count === "number" ? String(game.rating_count) : "0"}
											data-rating-average={
												typeof game.rating_average === "number"
													? String(game.rating_average)
													: ""
											}
											tabindex="0"
										>
											Member Rating: {formatRatingSummaryText(game.rating_average, game.rating_count)}
										</p>
										<div class="game-rating-hover">
											<ul class="game-rating-hover-list" data-game-id={game.id}></ul>
										</div>
									</div>
								</article>
							))}
					</div>
				</section>
				</div>
			</main>

		<AppFooter />
			<dialog class="modal" id="meeting-modal">
				<form class="modal-card meeting-form" novalidate>
				<header>
					<h3>Set next meeting</h3>
					<button class="ghost icon-button" type="button" data-action="close-meeting" aria-label="Close">
						×
					</button>
				</header>
				<div class="meeting-grid">
					<div class="field">
						<label for="meeting-date">Date</label>
						<input id="meeting-date" name="date" type="date" required />
					</div>
					<div class="field">
						<label for="meeting-time">Time</label>
						<input id="meeting-time" name="time" type="time" step="300" required />
					</div>
				</div>
				<p class="form-error hidden" id="meeting-error" role="alert"></p>
				<footer>
					<button class="ghost" type="button" data-action="close-meeting">Cancel</button>
					<button class="cta" type="submit">Save</button>
				</footer>
				</form>
			</dialog>
			<dialog class="modal" id="add-game-modal">
				<form class="modal-card add-game-form" novalidate>
					<header>
						<h3>Add a game</h3>
						<button class="ghost icon-button" type="button" data-action="close-add-game" aria-label="Close">
							×
						</button>
					</header>
					<div class="field">
						<label for="game-title">Game title</label>
						<input id="game-title" name="title" type="text" placeholder="Search for a game" autocomplete="off" required />
					</div>
					<ul class="suggestions" aria-live="polite" role="listbox"></ul>
					<p class="muted small">Start typing to see suggestions.</p>
					<p class="form-error hidden" id="add-game-error" role="alert"></p>
					<footer>
						<button class="ghost" type="button" data-action="close-add-game">Cancel</button>
						<button class="cta" type="submit">Submit</button>
					</footer>
				</form>
			</dialog>
			<dialog class="modal" id="eligibility-modal">
				<form class="modal-card eligibility-form" method="dialog">
					<header>
						<h3>Set poll eligibility</h3>
						<button class="ghost icon-button" type="button" data-action="close-eligibility" aria-label="Close">
							×
						</button>
					</header>
					<p class="muted small eligibility-summary">Select up to 2 of your backlog games.</p>
					<p class="muted small eligibility-count"></p>
					<div class="eligibility-list" role="list"></div>
					<p class="form-error hidden eligibility-error" role="alert"></p>
					<footer>
						<button class="ghost" type="button" data-action="close-eligibility">Done</button>
					</footer>
				</form>
			</dialog>
			<dialog class="modal" id="game-detail-modal">
				<form class="modal-card game-detail-card" method="dialog">
					<header>
						<div class="game-detail-title-row">
							<button
								class="ghost icon-button favorite-toggle game-detail-favorite"
								type="button"
								aria-label="Add to favorites"
								title="Add to favorites"
								aria-pressed="false"
							>
								<span class="favorite-icon" aria-hidden="true">♡</span>
							</button>
							<h3 class="game-detail-title">Game title</h3>
						</div>
						<button class="ghost icon-button" type="button" data-action="close-game-detail" aria-label="Close">
							×
						</button>
					</header>
						<div class="game-detail-body">
							<img class="game-detail-cover" alt="" />
							<div class="game-detail-info">
							<p class="meta-line tight game-detail-tags"></p>
							<p class="game-detail-description"></p>
							<div class="game-detail-links">
								<a class="ghost small-pill game-detail-steam" target="_blank" rel="noreferrer" title="View on Steam">Steam</a>
								<a class="ghost small-pill game-detail-hltb" target="_blank" rel="noreferrer" title="View on HowLongToBeat">HLTB</a>
								<a class="ghost small-pill game-detail-itad" target="_blank" rel="noreferrer" title="View on IsThereAnyDeal">ITAD</a>
							</div>
							<div class="game-detail-rating-wrap">
								<p class="meta-line tight game-detail-rating-summary" tabindex="0">Member Rating: No ratings yet</p>
								<div class="game-detail-rating-hover">
									<ul class="game-detail-rating-hover-list"></ul>
								</div>
							</div>
							<div class="game-detail-ttb-edit hidden">
								<div class="field">
									<label for="game-detail-ttb">Time to beat (hours)</label>
									<div class="game-detail-ttb-row">
										<input id="game-detail-ttb" type="number" min="0" step="0.5" />
										<button class="ghost small-pill game-detail-ttb-save" type="button">Save TTB</button>
									</div>
								</div>
								<p class="form-error hidden game-detail-ttb-error" role="alert"></p>
							</div>
								<p class="meta-line tight game-detail-prices">Current low: TBD · Historical low: TBD</p>
								<p class="muted small game-detail-submitted"></p>
								<div class="game-detail-eligibility hidden">
									<label class="toggle-control" for="game-detail-poll-eligible">
										<span>Poll eligible</span>
										<span class="toggle-switch">
											<input id="game-detail-poll-eligible" type="checkbox" />
											<span class="toggle-slider"></span>
										</span>
									</label>
									<p class="muted small game-detail-eligibility-help">Select up to 2 of your backlog games.</p>
								</div>
							</div>
						</div>
						<p class="form-error hidden game-detail-action-error" role="alert"></p>
						<footer class="game-detail-footer">
						<button class="ghost game-detail-rate hidden" type="button">Rate</button>
						<button class="ghost game-detail-set-current hidden" type="button">Set current</button>
						<button class="ghost danger game-detail-delete hidden" type="button">Delete</button>
					</footer>
				</form>
			</dialog>
			<dialog class="modal" id="rate-game-modal">
				<form class="modal-card rate-game-card" method="dialog">
					<header>
						<h3 class="rate-game-title">Rate game</h3>
						<button class="ghost icon-button" type="button" data-action="close-rate-game" aria-label="Close">
							×
						</button>
					</header>
					<div class="rate-game-controls">
						<div class="rate-game-stars">
							<button class="rate-star-button" type="button" data-rating-value="1" aria-label="Rate 1 star">☆</button>
							<button class="rate-star-button" type="button" data-rating-value="2" aria-label="Rate 2 stars">☆</button>
							<button class="rate-star-button" type="button" data-rating-value="3" aria-label="Rate 3 stars">☆</button>
							<button class="rate-star-button" type="button" data-rating-value="4" aria-label="Rate 4 stars">☆</button>
							<button class="rate-star-button" type="button" data-rating-value="5" aria-label="Rate 5 stars">☆</button>
						</div>
						<button class="rate-clear-button" type="button" data-action="clear-rate-game">Clear</button>
					</div>
					<p class="form-error hidden rate-game-error" role="alert"></p>
					<footer>
						<button class="ghost" type="button" data-action="close-rate-game">Done</button>
					</footer>
				</form>
			</dialog>
			<script define:vars={{ initialPollState: pollState ?? null, initialUser }}>
			const pollChip = document.querySelector("#poll-chip");
			const pollStatus = document.querySelector("#poll-status");
			const pollResults = document.querySelector("#poll-results");
			const pollMeta = document.querySelector("#poll-meta");
			const pollVoteForm = document.querySelector("#poll-vote-form");
			const pollChoice1 = document.querySelector("#poll-choice-1");
			const pollChoice2 = document.querySelector("#poll-choice-2");
			const pollChoice3 = document.querySelector("#poll-choice-3");
			const pollError = document.querySelector("#poll-error");
			const startButton = document.querySelector("[data-action='start-poll']");
			const closeButton = document.querySelector("[data-action='close-poll']");
			const openEligibilityButton = document.querySelector("[data-action='open-eligibility']");
			const meetingNode = document.querySelector("#next-meeting");
			const meetingModal = document.querySelector("#meeting-modal");
			const meetingDate = document.querySelector("#meeting-date");
			const meetingTime = document.querySelector("#meeting-time");
			const meetingError = document.querySelector("#meeting-error");
			let isAuthenticated = Boolean(initialUser?.email);
			let isAdmin = initialUser?.role === "admin";
			let currentPollState = initialPollState;

			function formatPollDate(value) {
				if (!value) return "TBD";
				const normalized = value.includes("T") ? value : value.replace(" ", "T") + "Z";
				const date = new Date(normalized);
				if (Number.isNaN(date.getTime())) return value;
				return date.toLocaleDateString("en-US", {
					month: "short",
					day: "numeric",
					year: "numeric"
				});
			}

			function clearElement(element) {
				if (!element) return;
				while (element.firstChild) {
					element.removeChild(element.firstChild);
				}
			}

			function setButtonVisibility({ canStart, canVote, canClose, canSetEligibility }) {
				if (startButton) startButton.classList.toggle("hidden", !canStart);
				if (closeButton) closeButton.classList.toggle("hidden", !canClose);
				if (openEligibilityButton) {
					openEligibilityButton.classList.toggle("hidden", !canSetEligibility);
				}
			}

			function renderResults(results, label) {
				if (!pollResults) return;
				clearElement(pollResults);
				if (label === null) {
					return;
				}
				if (!results || results.length === 0) {
					const empty = document.createElement("p");
					empty.className = "muted small";
					empty.textContent = label || "No results yet.";
					pollResults.appendChild(empty);
					return;
				}
				const list = document.createElement("ol");
				list.className = "poll-results-list";
				results.forEach((result, index) => {
					const item = document.createElement("li");
					item.className = "poll-result";

					const title = document.createElement("span");
					title.className = "poll-result-title";
					title.textContent = `${index + 1}. ${result.title}`;

					const points = document.createElement("span");
					points.className = "poll-result-points";
					points.textContent = `${result.points ?? 0} pts`;

					item.appendChild(title);
					item.appendChild(points);
					list.appendChild(item);
				});
				pollResults.appendChild(list);
			}

			function renderPoll(state) {
				if (!pollStatus || !pollChip || !pollMeta) return;

				if (!state) {
					pollChip.textContent = "Offline";
					pollChip.classList.remove("hidden");
					pollStatus.textContent = "Unable to load poll status.";
					pollMeta.textContent = "";
					renderResults([], "No poll data available.");
					setButtonVisibility({
						canStart: false,
						canVote: false,
						canClose: false,
						canSetEligibility: false
					});
					return;
				}

				if (state.active) {
					pollChip.textContent = "Voting live!";
					pollChip.classList.add("is-active");
					pollChip.classList.remove("hidden");
					pollStatus.textContent = state.hasVoted ? "Current standings:" : "";
					pollMeta.textContent = `Started ${formatPollDate(state.poll?.started_at)}`;
					if (!isAuthenticated) {
						renderResults([], "Sign in to vote.");
						setButtonVisibility({
							canStart: false,
							canVote: false,
							canClose: false,
							canSetEligibility: false
						});
						toggleVoteForm(false);
					} else if (state.hasVoted) {
						renderResults(state.results || [], "Results will appear after votes land.");
						setButtonVisibility({
							canStart: false,
							canVote: false,
							canClose: true,
							canSetEligibility: false
						});
						toggleVoteForm(false);
					} else {
						renderResults([], null);
						setButtonVisibility({
							canStart: false,
							canVote: false,
							canClose: false,
							canSetEligibility: false
						});
						toggleVoteForm(true);
					}
				} else {
					pollChip.textContent = "Inactive";
					pollChip.classList.remove("is-active");
					pollChip.classList.add("hidden");
					pollStatus.textContent = "";
					pollMeta.textContent = state.poll
						? `Results from: ${formatPollDate(state.poll.closed_at || state.poll.started_at)} · Inactive`
						: "No polls yet.";
					renderResults(state.results || [], "No poll results yet.");
					setButtonVisibility({
						canStart: isAuthenticated,
						canVote: false,
						canClose: false,
						canSetEligibility: isAuthenticated
					});
					toggleVoteForm(false);
				}
			}

			function populateChoices(choices) {
				const selects = [pollChoice1, pollChoice2, pollChoice3];
				const selectedValues = selects.map((select) => (select ? select.value : ""));
				const sortedChoices = Array.isArray(choices)
					? [...choices].sort((a, b) => (a.title || "").localeCompare(b.title || ""))
					: [];
				selects.forEach((select, index) => {
					if (!select) return;
					const placeholder = select.querySelector("option");
					clearElement(select);
					if (placeholder) {
						select.appendChild(placeholder);
					}
					sortedChoices.forEach((choice) => {
						const option = document.createElement("option");
						option.value = String(choice.id);
						const favoritePrefix = choice?.is_favorite ? "♥ " : "♡ ";
						option.textContent = `${favoritePrefix}${choice.title}`;
						select.appendChild(option);
					});
					if (selectedValues[index]) {
						select.value = selectedValues[index];
					}
				});
			}

			function toggleVoteForm(show) {
				if (!pollVoteForm) return;
				pollVoteForm.classList.toggle("hidden", !show);
				const selects = [pollChoice1, pollChoice2, pollChoice3];
				selects.forEach((select) => {
					if (!select) return;
					select.disabled = !show;
				});
				if (!show) {
					selects.forEach((select) => {
						if (select) select.value = "";
					});
					setPollError("");
				}
			}

			function setPollError(message) {
				if (!pollError) return;
				if (message) {
					pollError.textContent = message;
					pollError.classList.remove("hidden");
				} else {
					pollError.textContent = "";
					pollError.classList.add("hidden");
				}
			}

			async function loadPollState() {
				const response = await fetch("/api/polls");
				if (!response.ok) {
					renderPoll(null);
					return null;
				}
				const data = await response.json();
				currentPollState = data;
				renderPoll(data);
				return data;
			}

			async function ensureAuthenticated(actionLabel) {
				const response = await fetch("/api/me");
				if (response.ok) return true;
				if (actionLabel) {
					pollStatus.textContent = `${actionLabel} requires signing in.`;
				}
				window.location.href = "/api/auth/login";
				return false;
			}

			async function startPoll() {
				const authed = await ensureAuthenticated("Starting a poll");
				if (!authed) return;
				const confirmed = window.confirm(
					"Start this poll now? Please confirm everyone has submitted and is ready to vote."
				);
				if (!confirmed) return;
				const response = await fetch("/api/polls", { method: "POST" });
				if (response.ok) {
					const updated = await loadPollState();
					if (updated?.active) {
						populateChoices(updated.choices || []);
					}
				} else {
					const message = await response.text();
					pollStatus.textContent = message || "Unable to start poll.";
				}
			}

			async function closePoll() {
				const authed = await ensureAuthenticated("Closing the poll");
				if (!authed) return;
				const confirmed = window.confirm(
					"Close this poll now? Please confirm all votes are in before closing."
				);
				if (!confirmed) return;
				const response = await fetch("/api/polls", {
					method: "PATCH",
					headers: { "Content-Type": "application/json" },
					body: JSON.stringify({ action: "close" })
				});
				if (response.ok) {
					await loadPollState();
				} else {
					const message = await response.text();
					pollStatus.textContent = message || "Unable to close poll.";
				}
			}

			if (startButton) {
				startButton.addEventListener("click", () => startPoll());
			}

			if (closeButton) {
				closeButton.addEventListener("click", () => closePoll());
			}

			if (pollVoteForm) {
				pollVoteForm.addEventListener("submit", async (event) => {
					event.preventDefault();
					const choices = [pollChoice1, pollChoice2, pollChoice3]
						.map((select) => (select ? select.value : ""))
						.filter(Boolean)
						.map((value) => Number.parseInt(value, 10))
						.filter((value) => Number.isInteger(value));

					if (choices.length === 0) {
						setPollError("Pick at least one game.");
						return;
					}
					const unique = new Set(choices);
					if (unique.size !== choices.length) {
						setPollError("Each choice must be unique.");
						return;
					}

					const response = await fetch("/api/polls/vote", {
						method: "POST",
						headers: { "Content-Type": "application/json" },
						body: JSON.stringify({ choices })
					});

					if (response.ok) {
						const updated = await loadPollState();
						if (updated?.active) {
							populateChoices(updated.choices || []);
						}
					} else if (response.status === 401) {
						window.location.href = "/api/auth/login";
					} else {
						const message = await response.text();
						setPollError(message || "Unable to submit vote.");
					}
				});
			}

			if (initialPollState?.active && !initialPollState?.hasVoted) {
				populateChoices(initialPollState?.choices || []);
			}
			renderPoll(initialPollState);

			if (meetingNode && isAdmin) {
				meetingNode.classList.add("editable");
				meetingNode.title = "Click to edit next meeting";
			}

			if (meetingNode) {
				meetingNode.textContent = formatMeetingLocal(meetingNode.dataset.iso || "");
			}

			if (meetingNode) {
				meetingNode.addEventListener("click", async () => {
					if (!isAdmin) return;
					populateMeetingForm(meetingNode.dataset.iso || "");
					if (meetingError) {
						meetingError.textContent = "";
						meetingError.classList.add("hidden");
					}
					meetingModal?.showModal();
				});
			}

			function populateMeetingForm(isoValue) {
				if (!meetingDate || !meetingTime) return;
				const parts = getMeetingParts(isoValue);
				meetingDate.value = parts.date;
				meetingTime.value = parts.time;
			}

			function getMeetingParts(isoValue) {
				if (!isoValue) {
					return { date: "", time: "20:15" };
				}
				const date = new Date(isoValue);
				if (Number.isNaN(date.getTime())) {
					return { date: "", time: "20:15" };
				}
				const formatter = new Intl.DateTimeFormat("en-US", {
					year: "numeric",
					month: "2-digit",
					day: "2-digit",
					hour: "numeric",
					minute: "2-digit",
					hour12: true
				});
				const parts = formatter.formatToParts(date);
				const lookup = (type) => parts.find((part) => part.type === type)?.value;
				const year = lookup("year") || "";
				const month = lookup("month") || "";
				const day = lookup("day") || "";
				const hour = lookup("hour") || "8";
				const minute = lookup("minute") || "15";
				const dayPeriod = lookup("dayPeriod") || "PM";
				const hourNumber = Number.parseInt(hour, 10);
				let hour24 = Number.isNaN(hourNumber) ? 20 : hourNumber % 12;
				if (dayPeriod === "PM") hour24 += 12;
				const pad = (value) => String(value).padStart(2, "0");
				return { date: `${year}-${month}-${day}`, time: `${pad(hour24)}:${minute}` };
			}

			if (meetingModal) {
				meetingModal.addEventListener("click", (event) => {
					const target = event.target;
					if (!(target instanceof HTMLElement)) return;
					if (target.closest("[data-action='close-meeting']")) {
						if (meetingError) {
							meetingError.textContent = "";
							meetingError.classList.add("hidden");
						}
						meetingModal.close();
					}
				});
				meetingModal.addEventListener("submit", async (event) => {
					event.preventDefault();
					if (meetingError) {
						meetingError.textContent = "";
						meetingError.classList.add("hidden");
					}
					if (!meetingDate || !meetingTime) return;
					const dateValue = meetingDate.value;
					const timeValue = meetingTime.value;
					if (!dateValue || !timeValue) return;
					const [hourText, minuteText] = timeValue.split(":");
					const hour24 = Number.parseInt(hourText, 10);
					const minuteValue = Number.parseInt(minuteText, 10);
					if (Number.isNaN(hour24) || Number.isNaN(minuteValue)) return;
					const [year, month, day] = dateValue.split("-").map((val) => Number.parseInt(val, 10));
					const localDate = new Date(year, month - 1, day, hour24, minuteValue);
					if (Number.isNaN(localDate.getTime())) return;
					const response = await fetch("/api/site-settings", {
						method: "PATCH",
						headers: { "Content-Type": "application/json" },
						body: JSON.stringify({ next_meeting: localDate.toISOString() })
					});
					if (response.ok) {
						window.location.reload();
					} else if (meetingError) {
						const message = await response.text();
						meetingError.textContent = message || "Unable to update next meeting.";
						meetingError.classList.remove("hidden");
					}
				});
			}

				const addButton = document.querySelector(".add-game");
				const addModal = document.querySelector("#add-game-modal");
				const addForm = document.querySelector(".add-game-form");
				const addError = document.querySelector("#add-game-error");
				const titleInput = document.querySelector("#game-title");
				const eligibilityModal = document.querySelector("#eligibility-modal");
				const eligibilityList = document.querySelector(".eligibility-list");
				const eligibilityCount = document.querySelector(".eligibility-count");
				const eligibilityError = document.querySelector(".eligibility-error");
				const suggestionList = document.querySelector(".suggestions");
				const detailModal = document.querySelector("#game-detail-modal");
				const detailTitle = document.querySelector(".game-detail-title");
				const detailTags = document.querySelector(".game-detail-tags");
				const detailDescription = document.querySelector(".game-detail-description");
				const detailSubmitted = document.querySelector(".game-detail-submitted");
				const detailCover = document.querySelector(".game-detail-cover");
				const detailDelete = document.querySelector(".game-detail-delete");
				const detailSetCurrent = document.querySelector(".game-detail-set-current");
				const detailRate = document.querySelector(".game-detail-rate");
				const detailFavorite = document.querySelector(".game-detail-favorite");
				const detailSteam = document.querySelector(".game-detail-steam");
				const detailHltb = document.querySelector(".game-detail-hltb");
				const detailItad = document.querySelector(".game-detail-itad");
				const detailPrices = document.querySelector(".game-detail-prices");
				const detailRatingWrap = document.querySelector(".game-detail-rating-wrap");
				const detailRatingSummary = document.querySelector(".game-detail-rating-summary");
				const detailRatingHoverList = document.querySelector(".game-detail-rating-hover-list");
				const detailTtbEdit = document.querySelector(".game-detail-ttb-edit");
				const detailTtbInput = document.querySelector("#game-detail-ttb");
				const detailTtbSave = document.querySelector(".game-detail-ttb-save");
				const detailTtbError = document.querySelector(".game-detail-ttb-error");
				const detailEligibility = document.querySelector(".game-detail-eligibility");
				const detailEligibilityToggle = document.querySelector("#game-detail-poll-eligible");
				const detailEligibilityHelp = document.querySelector(".game-detail-eligibility-help");
				const detailActionError = document.querySelector(".game-detail-action-error");
				const currentGameRateButton = document.querySelector(".rate-current-game");
				const cardRatingWraps = Array.from(document.querySelectorAll(".game-rating-wrap"));
				const rateGameModal = document.querySelector("#rate-game-modal");
				const rateGameTitle = document.querySelector(".rate-game-title");
				const rateGameError = document.querySelector(".rate-game-error");
				const rateGameStars = Array.from(document.querySelectorAll(".rate-star-button"));
				const backlogFeedback = document.querySelector("#backlog-feedback");
				const tableBody = document.querySelector(".games-table tbody");
				const sortHeaders = document.querySelectorAll(".games-table th[data-sort]");
				const rowTooltip = document.querySelector(".row-tooltip");
				const tooltipDescription = rowTooltip?.querySelector(".tooltip-description");
				const tooltipTags = rowTooltip?.querySelector(".tooltip-tags");
				const steamIdKey = "steamAppId";
				let selectedGameId = null;
				let selectedGameIsMine = false;
				let selectedGamePollEligible = false;
				let selectedGameFavorite = false;
				let selectedGameMyRating = null;
				let activeRateGameId = null;
				let activeRateGameTitle = "";
				let currentUserRole = initialUser?.role || "";
				let isSignedIn = Boolean(initialUser?.email);
				const MAX_MEMBER_ELIGIBLE = 2;
				const ratingRowsByGame = new Map();

				function getFirstName(value) {
					if (!value) return "";
					return String(value).trim().split(/\s+/)[0] || "";
				}

				if (addButton && isSignedIn) {
					addButton.classList.remove("hidden");
				}
				if (currentGameRateButton && isSignedIn) {
					currentGameRateButton.classList.remove("hidden");
				}
				cardRatingWraps.forEach((wrap) => {
					if (!(wrap instanceof HTMLElement)) return;
					wrap.classList.toggle("has-hover", isSignedIn);
					const gameId = wrap.dataset.gameId;
					wrap.addEventListener("mouseenter", () => {
						if (!gameId || !isSignedIn) return;
						ensureGameRatingsLoaded(gameId);
					});
					wrap.addEventListener("focusin", () => {
						if (!gameId || !isSignedIn) return;
						ensureGameRatingsLoaded(gameId);
					});
				});

				document.addEventListener("click", async (event) => {
					const target = event.target;
					if (!(target instanceof HTMLElement)) return;
					const favoriteToggle = target.closest(".favorite-toggle");
					if (favoriteToggle instanceof HTMLElement) {
						event.preventDefault();
						event.stopPropagation();
						const isDetailToggle = favoriteToggle.classList.contains("game-detail-favorite");
						const gameId = isDetailToggle ? selectedGameId : favoriteToggle.dataset.gameId;
						if (!gameId) return;
						const currentFavorite = isDetailToggle
							? selectedGameFavorite
							: favoriteToggle.dataset.favorite === "1";
						await toggleFavorite(String(gameId), !currentFavorite);
						return;
					}
					if (target.closest(".add-game")) {
						if (!isSignedIn) {
							window.location.href = "/api/auth/login";
							return;
						}
						clearFormError();
						addModal?.showModal();
					}
					if (target.closest("[data-action='open-eligibility']")) {
						if (!isSignedIn) {
							window.location.href = "/api/auth/login";
							return;
						}
						openEligibilityModal();
						return;
					}
					if (target.closest("[data-action='close-eligibility']")) {
						setEligibilityError("");
						eligibilityModal?.close();
					}
					if (target.closest("[data-action='close-add-game']")) {
						addModal?.close();
					}
					if (target.closest("[data-action='close-game-detail']")) {
						detailModal?.close();
					}
					if (target.closest("[data-action='close-rate-game']")) {
						rateGameModal?.close();
					}
					if (target.closest("[data-action='clear-rate-game']")) {
						if (activeRateGameId) {
							await submitGameRating(activeRateGameId, null);
						}
						return;
					}
					const currentRate = target.closest(".rate-current-game");
					if (currentRate instanceof HTMLElement) {
						const gameId = currentRate.dataset.gameId;
						const title = currentRate.dataset.gameTitle || "Game";
						if (gameId) {
							openRateGameModal(gameId, title);
						}
						return;
					}
					const selected = target.closest(".suggestion-item");
					if (selected && titleInput) {
						applySuggestion(selected);
					}
					const card = target.closest(".game-card");
					if (card && detailModal) {
						openGameDetail(card);
					}
					const row = target.closest(".game-row");
					if (row && detailModal) {
						openGameDetail(row);
					}
				});

				document.addEventListener("keydown", (event) => {
					const target = event.target;
					if (!(target instanceof HTMLElement)) return;
					if (!target.classList.contains("suggestion-item")) return;
					if (event.key !== "Enter" && event.key !== " ") return;
					event.preventDefault();
					applySuggestion(target);
				});

				const tableRows = tableBody
					? Array.from(tableBody.querySelectorAll(".game-row"))
					: [];

				function getOwnedBacklogRows() {
					return tableRows.filter((row) => row.dataset.isMine === "1");
				}

				function getOwnedEligibleCount() {
					return getOwnedBacklogRows().filter((row) => row.dataset.pollEligible === "1").length;
				}

				function updateEligibilityCountText() {
					if (!eligibilityCount) return;
					const count = getOwnedEligibleCount();
					eligibilityCount.textContent = `${count} of ${MAX_MEMBER_ELIGIBLE} selected`;
				}

				function setEligibilityError(message) {
					if (!eligibilityError) return;
					if (message) {
						eligibilityError.textContent = message;
						eligibilityError.classList.remove("hidden");
					} else {
						eligibilityError.textContent = "";
						eligibilityError.classList.add("hidden");
					}
				}

				function getRowByGameId(gameId) {
					return tableRows.find((row) => Number.parseInt(row.dataset.id || "", 10) === gameId) || null;
				}

				function getActiveSort() {
					const activeHeader = Array.from(sortHeaders).find((header) => header.dataset.direction);
					if (!activeHeader) {
						return { key: "title", direction: "asc" };
					}
					return {
						key: activeHeader.dataset.sort || "title",
						direction: activeHeader.dataset.direction || "asc"
					};
				}

				function applyGamePollEligibleState(gameId, isEligible) {
					const row = getRowByGameId(gameId);
					if (!row) return;
					row.dataset.pollEligible = isEligible ? "1" : "0";
					row.classList.toggle("is-poll-ineligible", !isEligible);
				}

				function syncEligibilityControls() {
					const eligibleCount = getOwnedEligibleCount();
					const reachedMax = eligibleCount >= MAX_MEMBER_ELIGIBLE;

					if (eligibilityList) {
						const toggles = eligibilityList.querySelectorAll(".eligibility-toggle");
						toggles.forEach((toggle) => {
							if (!(toggle instanceof HTMLInputElement)) return;
							const gameId = Number.parseInt(toggle.dataset.gameId || "", 10);
							const row = Number.isNaN(gameId) ? null : getRowByGameId(gameId);
							const isEligible = row?.dataset.pollEligible === "1";
							toggle.checked = isEligible;
							toggle.disabled = !isEligible && reachedMax;
						});
					}

					if (detailEligibilityToggle) {
						const disableEnable = !selectedGamePollEligible && reachedMax;
						detailEligibilityToggle.disabled = disableEnable;
						if (detailEligibilityHelp) {
							detailEligibilityHelp.textContent = disableEnable
								? "You already have 2 eligible games. Mark one ineligible first."
								: "Select up to 2 of your backlog games.";
						}
					}

					updateEligibilityCountText();
				}

				function renderEligibilityList() {
					if (!eligibilityList) return;
					eligibilityList.innerHTML = "";
					const rows = getOwnedBacklogRows().sort((a, b) =>
						(a.dataset.titleSort || "").localeCompare(b.dataset.titleSort || "")
					);
					if (rows.length === 0) {
						const empty = document.createElement("p");
						empty.className = "muted small";
						empty.textContent = "You do not have any backlog games yet.";
						eligibilityList.appendChild(empty);
						updateEligibilityCountText();
						return;
					}

					rows.forEach((row) => {
						const gameId = Number.parseInt(row.dataset.id || "", 10);
						if (Number.isNaN(gameId)) return;
						const isEligible = row.dataset.pollEligible === "1";

						const item = document.createElement("div");
						item.className = "eligibility-item";

						const title = document.createElement("span");
						title.className = "eligibility-title";
						title.textContent = row.dataset.title || "Untitled game";

						const label = document.createElement("label");
						label.className = "toggle-switch";

						const input = document.createElement("input");
						input.type = "checkbox";
						input.className = "eligibility-toggle";
						input.dataset.gameId = String(gameId);
						input.checked = isEligible;

						const slider = document.createElement("span");
						slider.className = "toggle-slider";

						label.appendChild(input);
						label.appendChild(slider);
						item.appendChild(title);
						item.appendChild(label);
						eligibilityList.appendChild(item);
					});

					syncEligibilityControls();
				}

				function openEligibilityModal() {
					if (!eligibilityModal) return;
					setEligibilityError("");
					renderEligibilityList();
					eligibilityModal.showModal();
				}

				function setGamePollEligibilityState(gameId, isEligible) {
					applyGamePollEligibleState(gameId, isEligible);
					const { key, direction } = getActiveSort();
					applySort(key, direction);

					if (selectedGameId && Number.parseInt(String(selectedGameId), 10) === gameId) {
						selectedGamePollEligible = isEligible;
						if (detailEligibilityToggle) {
							detailEligibilityToggle.checked = isEligible;
						}
					}

					syncEligibilityControls();
				}

				async function updatePollEligibility(gameIdText, pollEligible, source) {
					if (!isSignedIn) {
						window.location.href = "/api/auth/login";
						return false;
					}
					const gameId = Number.parseInt(String(gameIdText), 10);
					if (Number.isNaN(gameId)) return false;

					const response = await fetch("/api/games/eligibility", {
						method: "POST",
						headers: { "Content-Type": "application/json" },
						body: JSON.stringify({ id: gameId, poll_eligible: pollEligible })
					});
					if (response.ok) {
						if (detailActionError) {
							detailActionError.textContent = "";
							detailActionError.classList.add("hidden");
						}
						setEligibilityError("");
						if (backlogFeedback) {
							backlogFeedback.textContent = "";
							backlogFeedback.classList.add("hidden");
						}
						setGamePollEligibilityState(gameId, pollEligible);
						return true;
					}
					if (response.status === 401) {
						window.location.href = "/api/auth/login";
						return false;
					}
					const message = await response.text();
					if (source === "detail" && detailActionError) {
						detailActionError.textContent = message || "Unable to update poll eligibility.";
						detailActionError.classList.remove("hidden");
					} else if (source === "modal") {
						setEligibilityError(message || "Unable to update poll eligibility.");
					} else {
						showBacklogFeedback(message || "Unable to update poll eligibility.");
					}
					return false;
				}

				if (addForm) {
					addForm.addEventListener("submit", async (event) => {
						event.preventDefault();
						const title = titleInput?.value.trim();
						if (!title) return;
						const steamAppId = titleInput?.dataset[steamIdKey];
						const response = await fetch("/api/games", {
							method: "POST",
							headers: { "Content-Type": "application/json" },
							body: JSON.stringify({ title, steamAppId })
						});
						if (response.ok) {
							addModal?.close();
							window.location.reload();
							return;
						}
						const message = await response.text();
						showFormError(message || "Unable to add game.");
					});
				}

				if (eligibilityList) {
					eligibilityList.addEventListener("change", async (event) => {
						const target = event.target;
						if (!(target instanceof HTMLInputElement)) return;
						if (!target.classList.contains("eligibility-toggle")) return;
						const gameId = Number.parseInt(target.dataset.gameId || "", 10);
						if (Number.isNaN(gameId)) return;
						const row = getRowByGameId(gameId);
						const previous = row?.dataset.pollEligible === "1";
						const ok = await updatePollEligibility(gameId, target.checked, "modal");
						if (!ok) {
							target.checked = previous;
						}
					});
				}

				if (detailEligibilityToggle) {
					detailEligibilityToggle.addEventListener("change", async () => {
						if (!selectedGameId) return;
						const nextValue = detailEligibilityToggle.checked;
						const ok = await updatePollEligibility(selectedGameId, nextValue, "detail");
						if (!ok) {
							detailEligibilityToggle.checked = selectedGamePollEligible;
						}
					});
				}

				bindSearch(titleInput, suggestionList);

				function getRowValue(row, key) {
					if (key === "title") return row.dataset.titleSort || "";
					if (key === "submitter") return row.dataset.submitterSort || "";
					if (key === "favorite") return Number.parseInt(row.dataset.favorite || "0", 10);
					if (key === "ttb") return Number.parseInt(row.dataset.ttb || "0", 10);
					if (key === "current") return Number.parseInt(row.dataset.currentPrice || "0", 10);
					return "";
				}

				function compareRows(a, b, key, direction) {
					const dir = direction === "desc" ? -1 : 1;
					const aEligible = Number.parseInt(a.dataset.pollEligible || "0", 10);
					const bEligible = Number.parseInt(b.dataset.pollEligible || "0", 10);
					if (aEligible !== bEligible) {
						return bEligible - aEligible;
					}
					if (key === "favorite") {
						const aFavorite = Number.parseInt(a.dataset.favorite || "0", 10);
						const bFavorite = Number.parseInt(b.dataset.favorite || "0", 10);
						const favoriteCompare = (aFavorite - bFavorite) * dir;
						if (favoriteCompare !== 0) return favoriteCompare;
						return (a.dataset.titleSort || "").localeCompare(b.dataset.titleSort || "");
					}
					const aValue = getRowValue(a, key);
					const bValue = getRowValue(b, key);
					if (typeof aValue === "number" && typeof bValue === "number") {
						const aScore = aValue || Number.MAX_SAFE_INTEGER;
						const bScore = bValue || Number.MAX_SAFE_INTEGER;
						return (aScore - bScore) * dir;
					}
					return String(aValue).localeCompare(String(bValue)) * dir;
				}

				function applySort(key, direction) {
					if (!tableBody) return;
					const sorted = [...tableRows].sort((a, b) => compareRows(a, b, key, direction));
					sorted.forEach((row) => tableBody.appendChild(row));
				}

				sortHeaders.forEach((header) => {
					header.addEventListener("click", () => {
						const key = header.dataset.sort;
						if (!key) return;
						const current = header.dataset.direction || "asc";
						const nextDirection = current === "asc" ? "desc" : "asc";
						sortHeaders.forEach((th) => {
							delete th.dataset.direction;
						});
						header.dataset.direction = nextDirection;
						applySort(key, nextDirection);
					});
				});

				applySort("title", "asc");
				updateEligibilityCountText();

				function applyFavoriteStateToButton(button, isFavorite) {
					if (!(button instanceof HTMLElement)) return;
					const icon = button.querySelector(".favorite-icon");
					if (icon) {
						icon.textContent = isFavorite ? "♥" : "♡";
					}
					button.classList.toggle("is-favorite", isFavorite);
					button.dataset.favorite = isFavorite ? "1" : "0";
					button.setAttribute("aria-pressed", isFavorite ? "true" : "false");
					button.setAttribute(
						"aria-label",
						isFavorite ? "Remove from favorites" : "Add to favorites"
					);
					button.setAttribute(
						"title",
						isFavorite ? "Remove from favorites" : "Add to favorites"
					);
				}

				function updatePollChoiceFavorites(gameId, isFavorite) {
					if (!currentPollState?.active || !Array.isArray(currentPollState?.choices)) return;
					let changed = false;
					currentPollState.choices.forEach((choice) => {
						if (Number.parseInt(String(choice.id), 10) !== gameId) return;
						choice.is_favorite = isFavorite ? 1 : 0;
						changed = true;
					});
					if (changed) {
						populateChoices(currentPollState.choices || []);
					}
				}

				function setGameFavoriteState(gameId, isFavorite) {
					tableRows.forEach((row) => {
						const rowGameId = Number.parseInt(row.dataset.id || "", 10);
						if (rowGameId !== gameId) return;
						row.dataset.favorite = isFavorite ? "1" : "0";
						const rowButton = row.querySelector(".favorite-toggle");
						applyFavoriteStateToButton(rowButton, isFavorite);
					});

					const playedCard = document.querySelector(`.game-card[data-id='${gameId}']`);
					if (playedCard instanceof HTMLElement) {
						playedCard.dataset.favorite = isFavorite ? "1" : "0";
					}

					if (selectedGameId && Number.parseInt(String(selectedGameId), 10) === gameId) {
						selectedGameFavorite = isFavorite;
						applyFavoriteStateToButton(detailFavorite, isFavorite);
					}

					updatePollChoiceFavorites(gameId, isFavorite);
				}

				function showFavoriteError(message) {
					const text = message || "Unable to update favorite.";
					if (detailModal?.open && detailActionError) {
						detailActionError.textContent = text;
						detailActionError.classList.remove("hidden");
						return;
					}
					showBacklogFeedback(text);
				}

				async function toggleFavorite(gameIdText, isFavorite) {
					if (!isSignedIn) {
						window.location.href = "/api/auth/login";
						return;
					}
					const gameId = Number.parseInt(gameIdText, 10);
					if (Number.isNaN(gameId)) return;
					const response = await fetch("/api/games/favorite", {
						method: "POST",
						headers: { "Content-Type": "application/json" },
						body: JSON.stringify({ id: gameId, favorite: isFavorite })
					});
					if (response.ok) {
						if (detailActionError) {
							detailActionError.textContent = "";
							detailActionError.classList.add("hidden");
						}
						if (backlogFeedback) {
							backlogFeedback.textContent = "";
							backlogFeedback.classList.add("hidden");
						}
						setGameFavoriteState(gameId, isFavorite);
						return;
					}
					if (response.status === 401) {
						window.location.href = "/api/auth/login";
						return;
					}
					const message = await response.text();
					showFavoriteError(message);
				}

				function parseRatingNumber(value) {
					if (value === null || value === undefined || value === "") return null;
					const parsed = Number.parseFloat(String(value));
					if (!Number.isFinite(parsed)) return null;
					return parsed;
				}

				function formatRatingStars(value) {
					const parsed = parseRatingNumber(value);
					if (parsed === null || parsed <= 0) return "☆☆☆☆☆";
					const rounded = Math.max(0, Math.min(5, Math.round(parsed)));
					return `${"★".repeat(rounded)}${"☆".repeat(5 - rounded)}`;
				}

				function formatRatingSummary(average, count) {
					const total = Number.parseInt(String(count || 0), 10);
					const parsedAverage = parseRatingNumber(average);
					if (!total || parsedAverage === null) {
						return "No ratings yet";
					}
					return `${formatRatingStars(parsedAverage)} ${parsedAverage.toFixed(1)} (${total})`;
				}

				function clearRateGameError() {
					if (!rateGameError) return;
					rateGameError.textContent = "";
					rateGameError.classList.add("hidden");
				}

				function setRateGameError(message) {
					if (!rateGameError) return;
					rateGameError.textContent = message;
					rateGameError.classList.remove("hidden");
				}

				function applyRateGameStarState(ratingValue) {
					rateGameStars.forEach((button) => {
						if (!(button instanceof HTMLElement)) return;
						const starValue = Number.parseInt(button.dataset.ratingValue || "", 10);
						const isActive = typeof ratingValue === "number" && starValue <= ratingValue;
						button.classList.toggle("is-active", isActive);
						button.textContent = isActive ? "★" : "☆";
					});
				}

				function renderDetailRatingHover(rows) {
					if (!detailRatingHoverList || !detailRatingWrap) return;
					detailRatingHoverList.innerHTML = "";
					if (!isSignedIn) {
						detailRatingWrap.classList.remove("has-hover");
						return;
					}
					detailRatingWrap.classList.add("has-hover");
					if (!Array.isArray(rows) || rows.length === 0) {
						const empty = document.createElement("li");
						empty.className = "muted small game-detail-rating-hover-row";
						empty.textContent = "No ratings yet.";
						detailRatingHoverList.appendChild(empty);
						return;
					}
					rows.forEach((row) => {
						const item = document.createElement("li");
						item.className = "game-detail-rating-hover-row";
						item.textContent = `${row.member_display_name || "Member"}: ${formatRatingStars(row.rating)}`;
						detailRatingHoverList.appendChild(item);
					});
				}

				function renderCardRatingHover(gameId, rows) {
					const wraps = document.querySelectorAll(`.game-rating-wrap[data-game-id='${gameId}']`);
					wraps.forEach((wrap) => {
						if (!(wrap instanceof HTMLElement)) return;
						const list = wrap.querySelector(".game-rating-hover-list");
						if (!(list instanceof HTMLElement)) return;
						list.innerHTML = "";
						if (!isSignedIn) {
							wrap.classList.remove("has-hover");
							return;
						}
						wrap.classList.add("has-hover");
						if (!Array.isArray(rows) || rows.length === 0) {
							const empty = document.createElement("li");
							empty.className = "muted small game-rating-hover-row";
							empty.textContent = "No ratings yet.";
							list.appendChild(empty);
							return;
						}
						rows.forEach((row) => {
							const item = document.createElement("li");
							item.className = "game-rating-hover-row";
							item.textContent = `${row.member_display_name || "Member"}: ${formatRatingStars(row.rating)}`;
							list.appendChild(item);
						});
					});
				}

				async function ensureGameRatingsLoaded(gameIdText) {
					const gameId = Number.parseInt(String(gameIdText), 10);
					if (Number.isNaN(gameId)) return;
					if (ratingRowsByGame.has(gameId)) {
						renderCardRatingHover(gameId, ratingRowsByGame.get(gameId) || []);
						if (selectedGameId && Number.parseInt(String(selectedGameId), 10) === gameId) {
							renderDetailRatingHover(ratingRowsByGame.get(gameId) || []);
						}
						return;
					}
					await loadGameRatings(gameId);
				}

				function openRateGameModal(gameIdText, gameTitle) {
					if (!isSignedIn) {
						window.location.href = "/api/auth/login";
						return;
					}
					const gameId = Number.parseInt(String(gameIdText), 10);
					if (Number.isNaN(gameId)) return;
					activeRateGameId = String(gameId);
					activeRateGameTitle = gameTitle || "Game";
					const gameNode = document.querySelector(`[data-id='${gameId}']`);
					const myRating = gameNode instanceof HTMLElement
						? Number.parseInt(gameNode.dataset.myRating || "", 10)
						: Number.NaN;
					selectedGameMyRating = Number.isNaN(myRating) ? null : myRating;
					if (rateGameTitle) {
						rateGameTitle.textContent = `Rate ${activeRateGameTitle}`;
					}
					applyRateGameStarState(selectedGameMyRating);
					clearRateGameError();
					rateGameModal?.showModal();
					loadGameRatings(gameId);
				}

				function updateRatingStateForGame(gameId, ratingAverage, ratingCount, myRating) {
					const normalizedCount = Number.parseInt(String(ratingCount || 0), 10) || 0;
					const averageText = ratingAverage === null || ratingAverage === undefined
						? ""
						: String(ratingAverage);
					const myRatingText =
						myRating === null || myRating === undefined ? "" : String(myRating);

					const gameNodes = document.querySelectorAll(`[data-id='${gameId}']`);
					gameNodes.forEach((node) => {
						if (!(node instanceof HTMLElement)) return;
						node.dataset.ratingCount = String(normalizedCount);
						node.dataset.ratingAverage = averageText;
						node.dataset.myRating = myRatingText;
					});

					const ratingSummaryNodes = document.querySelectorAll(
						`.game-rating-summary[data-game-id='${gameId}']`
					);
					ratingSummaryNodes.forEach((node) => {
						if (!(node instanceof HTMLElement)) return;
						node.dataset.ratingCount = String(normalizedCount);
						node.dataset.ratingAverage = averageText;
						node.textContent = `Member Rating: ${formatRatingSummary(ratingAverage, normalizedCount)}`;
					});

					if (
						selectedGameId &&
						Number.parseInt(String(selectedGameId), 10) === gameId &&
						detailRatingSummary
					) {
						detailRatingSummary.textContent = `Member Rating: ${formatRatingSummary(
							ratingAverage,
							normalizedCount
						)}`;
						if (typeof myRating === "number" || myRating === null) {
							selectedGameMyRating = myRating;
						}
						renderDetailRatingHover(ratingRowsByGame.get(gameId) || []);
					}

					if (
						activeRateGameId &&
						Number.parseInt(String(activeRateGameId), 10) === gameId
					) {
						const resolvedMyRating =
							typeof myRating === "number" ? myRating : myRating === null ? null : selectedGameMyRating;
						selectedGameMyRating = resolvedMyRating;
						applyRateGameStarState(resolvedMyRating);
					}
					renderCardRatingHover(gameId, ratingRowsByGame.get(gameId) || []);
				}

				async function loadGameRatings(gameIdText) {
					const gameId = Number.parseInt(String(gameIdText), 10);
					if (Number.isNaN(gameId)) return;
					const response = await fetch(`/api/games/rating?id=${gameId}`);
					if (!response.ok) {
						if (activeRateGameId && Number.parseInt(String(activeRateGameId), 10) === gameId) {
							setRateGameError("Unable to load ratings.");
						}
						return;
					}
					const payload = await response.json();
					clearRateGameError();
					const ratingRows = Array.isArray(payload.ratings) ? payload.ratings : [];
					ratingRowsByGame.set(gameId, ratingRows);
					updateRatingStateForGame(
						gameId,
						payload.rating_average,
						payload.rating_count,
						payload.my_rating
					);
					if (selectedGameId && Number.parseInt(String(selectedGameId), 10) === gameId) {
						renderDetailRatingHover(ratingRows);
					}
					renderCardRatingHover(gameId, ratingRows);
				}

				async function submitGameRating(gameIdText, ratingValue) {
					const gameId = Number.parseInt(String(gameIdText), 10);
					if (Number.isNaN(gameId)) return;
					const response = await fetch("/api/games/rating", {
						method: "POST",
						headers: { "Content-Type": "application/json" },
						body: JSON.stringify({ id: gameId, rating: ratingValue })
					});
					if (response.ok) {
						const payload = await response.json();
						clearRateGameError();
						updateRatingStateForGame(
							gameId,
							payload.rating_average,
							payload.rating_count,
							payload.my_rating
						);
						await loadGameRatings(gameId);
						return;
					}
					if (response.status === 401) {
						window.location.href = "/api/auth/login";
						return;
					}
					const message = await response.text();
					setRateGameError(message || "Unable to save rating.");
				}

				if (rowTooltip && tooltipDescription && tooltipTags && tableRows.length > 0) {
					let activeRow = null;

					function parseTagList(value) {
						if (!value) return [];
						try {
							const parsed = JSON.parse(value);
							return Array.isArray(parsed) ? parsed.filter(Boolean) : [];
						} catch {
							return [];
						}
					}

					function setTooltipContent(row) {
						const description = row.dataset.description?.trim() || "";
						const tags = parseTagList(row.dataset.tags || "");
						if (!description && tags.length === 0) {
							rowTooltip.classList.remove("visible");
							rowTooltip.setAttribute("aria-hidden", "true");
							return false;
						}
						tooltipDescription.textContent = description || "No description available.";
						tooltipDescription.classList.toggle("muted", !description);
						tooltipDescription.classList.toggle("small", !description);
						tooltipTags.textContent = tags.length ? tags.join(" • ") : "";
						rowTooltip.classList.add("visible");
						rowTooltip.setAttribute("aria-hidden", "false");
						return true;
					}

					function positionTooltip(event) {
						const offset = 16;
						const width = rowTooltip.offsetWidth;
						const height = rowTooltip.offsetHeight;
						let x = event.clientX + offset;
						let y = event.clientY + offset;
						if (x + width > window.innerWidth - 12) {
							x = event.clientX - width - offset;
						}
						if (y + height > window.innerHeight - 12) {
							y = event.clientY - height - offset;
						}
						rowTooltip.style.left = `${Math.max(12, x)}px`;
						rowTooltip.style.top = `${Math.max(12, y)}px`;
					}

					tableRows.forEach((row) => {
						row.addEventListener("mouseenter", (event) => {
							activeRow = row;
							const shouldShow = setTooltipContent(row);
							if (shouldShow) positionTooltip(event);
						});
						row.addEventListener("mousemove", (event) => {
							if (activeRow !== row || !rowTooltip.classList.contains("visible")) return;
							positionTooltip(event);
						});
						row.addEventListener("mouseleave", () => {
							if (activeRow !== row) return;
							activeRow = null;
							rowTooltip.classList.remove("visible");
							rowTooltip.setAttribute("aria-hidden", "true");
						});
					});
				}

				if (detailDelete) {
					detailDelete.addEventListener("click", async () => {
						if (!selectedGameId) return;
						const confirmed = window.confirm("Delete this game? This cannot be undone.");
						if (!confirmed) return;
						const response = await fetch("/api/games", {
							method: "DELETE",
							headers: { "Content-Type": "application/json" },
							body: JSON.stringify({ id: selectedGameId })
						});
						if (response.ok) {
							detailModal?.close();
							window.location.reload();
						} else if (detailActionError) {
							const message = await response.text();
							detailActionError.textContent = message || "Unable to delete game.";
							detailActionError.classList.remove("hidden");
						}
					});
				}

				if (detailTtbSave) {
					detailTtbSave.addEventListener("click", async () => {
						if (!selectedGameId || !detailTtbInput) return;
						const hoursValue = detailTtbInput.value.trim();
						const parsed = Number.parseFloat(hoursValue);
						if (!hoursValue || Number.isNaN(parsed) || parsed < 0) {
							if (detailTtbError) {
								detailTtbError.textContent = "Enter a valid number of hours.";
								detailTtbError.classList.remove("hidden");
							}
							return;
						}
						const response = await fetch("/api/games/ttb", {
							method: "POST",
							headers: { "Content-Type": "application/json" },
							body: JSON.stringify({
								id: Number.parseInt(String(selectedGameId), 10),
								time_to_beat_hours: parsed
							})
						});
						if (response.ok) {
							detailModal?.close();
							window.location.reload();
						} else if (detailTtbError) {
							detailTtbError.textContent = "Unable to save time to beat.";
							detailTtbError.classList.remove("hidden");
						}
					});
				}

				if (detailRate) {
					detailRate.addEventListener("click", () => {
						if (!selectedGameId || !detailTitle) return;
						openRateGameModal(selectedGameId, detailTitle.textContent || "Game");
					});
				}

				rateGameStars.forEach((button) => {
					button.addEventListener("click", async () => {
						if (!activeRateGameId) return;
						const ratingValue = Number.parseInt(button.dataset.ratingValue || "", 10);
						if (Number.isNaN(ratingValue)) return;
						await submitGameRating(activeRateGameId, ratingValue);
					});
				});

				if (rateGameModal) {
					rateGameModal.addEventListener("close", () => {
						activeRateGameId = null;
						clearRateGameError();
					});
				}

				if (detailSetCurrent) {
					detailSetCurrent.addEventListener("click", async () => {
						if (!selectedGameId) return;
						const response = await fetch("/api/games", {
							method: "PATCH",
							headers: { "Content-Type": "application/json" },
							body: JSON.stringify({ id: selectedGameId, action: "set-current" })
						});
						if (response.ok) {
							detailModal?.close();
							window.location.reload();
						} else {
							const message = (await response.text()) || "Unable to set current game.";
							detailModal?.close();
							if (response.status === 404) {
								showBacklogFeedback("That game no longer exists. Refreshing list...");
								setTimeout(() => window.location.reload(), 1800);
								return;
							}
							showBacklogFeedback(message);
						}
					});
				}

				function bindSearch(input, list) {
					if (!input || !list) return;
					let searchTimer;
					let requestVersion = 0;
					let activeController = null;
					input.addEventListener("input", () => {
						clearFormError();
						if (input === titleInput) {
							input.dataset[steamIdKey] = "";
						}
						const value = input.value.trim();
						if (searchTimer) clearTimeout(searchTimer);
						if (activeController) {
							activeController.abort();
							activeController = null;
						}
						if (!value) {
							requestVersion += 1;
							clearSuggestions(list);
							return;
						}
						const nextVersion = requestVersion + 1;
						requestVersion = nextVersion;
						searchTimer = setTimeout(async () => {
							const controller = new AbortController();
							activeController = controller;
							try {
								const response = await fetch(
									`/api/games/search?term=${encodeURIComponent(value)}`,
									{ signal: controller.signal }
								);
								if (nextVersion !== requestVersion) return;
								if (!response.ok) {
									renderSuggestions(list, []);
									return;
								}
								const data = await response.json();
								if (nextVersion !== requestVersion) return;
								renderSuggestions(list, data.results || []);
							} catch (error) {
								if (nextVersion !== requestVersion) return;
								if (error instanceof Error && error.name === "AbortError") {
									return;
								}
								renderSuggestions(list, []);
							} finally {
								if (activeController === controller) {
									activeController = null;
								}
							}
						}, 300);
					});
				}

				function showFormError(message) {
					if (!addError) return;
					addError.textContent = message;
					addError.classList.remove("hidden");
				}

				function clearFormError() {
					if (!addError) return;
					addError.textContent = "";
					addError.classList.add("hidden");
				}

				function showBacklogFeedback(message) {
					if (!backlogFeedback) return;
					backlogFeedback.textContent = message;
					backlogFeedback.classList.remove("hidden");
				}

				function renderSuggestions(list, items) {
					if (!list) return;
					list.innerHTML = "";
					if (items.length === 0) {
						const empty = document.createElement("li");
						empty.className = "muted small";
						empty.textContent = "No matches yet.";
						list.appendChild(empty);
						return;
					}
					items.forEach((item) => {
						const entry = document.createElement("li");
						entry.className = "suggestion-item";
						entry.textContent = item.name;
						entry.dataset.name = item.name;
						if (item.steamId) {
							entry.dataset.steamId = String(item.steamId);
						}
						entry.setAttribute("role", "option");
						entry.tabIndex = 0;
						list.appendChild(entry);
					});
				}

				function clearSuggestions(list) {
					if (!list) return;
					list.innerHTML = "";
				}

				function applySuggestion(selected) {
					if (!titleInput) return;
					titleInput.value = selected?.dataset.name || selected?.textContent || "";
					titleInput.dataset[steamIdKey] = selected?.dataset.steamId || "";
					clearSuggestions(suggestionList);
					titleInput.focus();
				}

				function openGameDetail(card) {
					if (!detailModal) return;
					const title = card.dataset.title || "Untitled game";
					const description = card.dataset.description || "Description coming soon.";
					const tags = card.dataset.tags ? parseTags(card.dataset.tags) : "Tags coming soon";
					const submittedName = card.dataset.submittedName || "";
					const submittedAlias = card.dataset.submittedAlias || "";
					const cover = card.dataset.cover || "";
					const steamAppId = card.dataset.steamAppId || "";
					const itadSlug = card.dataset.itadSlug || "";
					const currentPrice = card.dataset.currentPrice || "";
					const bestPrice = card.dataset.bestPrice || "";
						const status = card.dataset.status || "";
						const ttbMinutes = card.dataset.ttbMinutes || "";
						const ratingCount = card.dataset.ratingCount || "0";
						const ratingAverage = card.dataset.ratingAverage || "";
						const myRatingValue = card.dataset.myRating || "";
						const isMine = card.dataset.isMine === "1";
						const isPollEligible = card.dataset.pollEligible === "1";
						const isFavorite = card.dataset.favorite === "1";
						selectedGameId = card.dataset.id || null;
						selectedGameIsMine = isMine;
						selectedGamePollEligible = isPollEligible;
						selectedGameFavorite = isFavorite;
					selectedGameMyRating = (() => {
						const parsed = Number.parseInt(myRatingValue, 10);
						return Number.isNaN(parsed) ? null : parsed;
					})();

					if (detailTitle) detailTitle.textContent = title;
					if (detailDescription) detailDescription.textContent = description;
					if (detailSubmitted) {
						const submitter = submittedAlias || getFirstName(submittedName) || "Member";
						detailSubmitted.textContent = `Submitted by ${submitter}`;
					}
					if (detailActionError) {
						detailActionError.classList.add("hidden");
						detailActionError.textContent = "";
					}
					applyFavoriteStateToButton(detailFavorite, isFavorite);
					if (detailRatingSummary) {
						detailRatingSummary.textContent = `Member Rating: ${formatRatingSummary(
							ratingAverage,
							ratingCount
						)}`;
					}
					renderDetailRatingHover([]);
					if (detailRatingWrap) {
						detailRatingWrap.classList.toggle("has-hover", isSignedIn);
					}
					if (detailCover) {
						if (cover) {
							detailCover.src = cover;
							detailCover.alt = title;
							detailCover.classList.remove("hidden");
						} else {
							detailCover.removeAttribute("src");
							detailCover.alt = "";
							detailCover.classList.add("hidden");
						}
					}
					if (detailSteam) {
						const steamUrl = steamAppId
							? `https://store.steampowered.com/app/${steamAppId}`
							: "";
						detailSteam.href = steamUrl;
						detailSteam.classList.toggle("hidden", !steamUrl);
					}
					if (detailHltb) {
						const hltbUrl = `https://howlongtobeat.com/?q=${encodeURIComponent(title)}`;
						detailHltb.href = hltbUrl;
						detailHltb.classList.toggle("hidden", !title);
					}
					if (detailItad) {
						const itadUrl = itadSlug
							? `https://isthereanydeal.com/game/${itadSlug}/info/`
							: "";
						detailItad.href = itadUrl;
						detailItad.classList.toggle("hidden", !itadUrl);
					}
					if (detailPrices) {
						detailPrices.textContent = `Current low: ${formatPriceForDetail(currentPrice)} · Historical low: ${formatPriceForDetail(bestPrice)}`;
					}
					if (detailTtbEdit) {
						const hasTtb = Boolean(ttbMinutes);
						detailTtbEdit.classList.toggle("hidden", hasTtb || !isSignedIn);
						if (detailTtbInput) detailTtbInput.value = "";
						if (detailTtbError) {
							detailTtbError.classList.add("hidden");
							detailTtbError.textContent = "";
						}
					}
					if (detailTags) {
						const tagLine = tags || "Tags coming soon";
						if (ttbMinutes) {
							detailTags.textContent = `${formatTtbHoursForDetail(ttbMinutes)} | ${tagLine}`;
						} else {
							detailTags.textContent = tagLine;
						}
					}
					if (detailDelete) {
						detailDelete.classList.toggle("hidden", !isSignedIn);
						if (isSignedIn) {
							detailDelete.disabled = false;
						}
					}
					if (detailSetCurrent) {
						const currentUserIsAdmin = currentUserRole === "admin";
						detailSetCurrent.classList.toggle("hidden", !currentUserIsAdmin);
						detailSetCurrent.disabled = status === "current";
					}
						if (detailRate) {
							detailRate.classList.toggle("hidden", !isSignedIn);
						}
						if (detailEligibility && detailEligibilityToggle) {
							const canEditEligibility = isSignedIn && selectedGameIsMine && status === "backlog";
							detailEligibility.classList.toggle("hidden", !canEditEligibility);
							detailEligibilityToggle.checked = selectedGamePollEligible;
							if (canEditEligibility) {
								syncEligibilityControls();
							}
						}

						detailModal.showModal();
					if (selectedGameId) {
						loadGameRatings(selectedGameId);
					}
				}

				function parseTags(value) {
					try {
						const parsed = JSON.parse(value);
						if (Array.isArray(parsed)) {
							return parsed.join(" · ");
						}
					} catch {}
					return value;
				}

				function formatTtbHoursForDetail(value) {
					const minutes = Number.parseFloat(String(value));
					if (!Number.isFinite(minutes) || minutes <= 0) return "0 Hours";
					const hours = minutes / 60;
					const rounded = Math.round(hours * 10) / 10;
					const text = rounded % 1 === 0 ? String(Math.trunc(rounded)) : String(rounded);
					return `${text} Hours`;
				}

				function formatPriceForDetail(value) {
					if (value === null || value === undefined || value === "") return "TBD";
					const cents = Number.parseInt(value, 10);
					if (Number.isNaN(cents)) return "TBD";
					return new Intl.NumberFormat("en-US", {
						style: "currency",
						currency: "USD"
					}).format(cents / 100);
				}

				function formatMeetingLocal(isoValue) {
					if (!isoValue) return "Next meeting: TBD";
				const date = new Date(isoValue);
				if (Number.isNaN(date.getTime())) return "Next meeting: TBD";
				const month = date.toLocaleString("en-US", { month: "long" });
				const day = date.getDate();
				const time = date.toLocaleString("en-US", {
					hour: "numeric",
					minute: "2-digit",
					hour12: true
				});
				return `Next meeting: ${month} ${formatOrdinal(day)} @ ${time}`;
			}

			function formatOrdinal(day) {
				if (day % 100 >= 11 && day % 100 <= 13) return `${day}th`;
				switch (day % 10) {
					case 1:
						return `${day}st`;
					case 2:
						return `${day}nd`;
					case 3:
						return `${day}rd`;
					default:
						return `${day}th`;
				}
			}
			</script>
		</body>
	</html>
