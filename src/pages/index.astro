---
import AppHeader from "../components/AppHeader.astro";
import AppFooter from "../components/AppFooter.astro";
import "../styles/base.css";

type Game = {
	id: number;
	title: string;
	status: "backlog" | "current" | "played";
	tags_json?: string;
	played_month?: string;
	cover_art_url?: string;
	itad_boxart_url?: string;
	description?: string;
	submitted_by_name?: string;
	submitted_by_alias?: string;
	steam_app_id?: number;
	itad_slug?: string;
	current_price_cents?: number;
	best_price_cents?: number;
	time_to_beat_minutes?: number;
};

const [currentResponse, pollResponse, settingsResponse, gamesResponse] = await Promise.all([
	fetch(new URL("/api/games/current", Astro.url), {
		headers: Astro.request.headers
	}),
	fetch(new URL("/api/polls", Astro.url), {
		headers: Astro.request.headers
	}),
	fetch(new URL("/api/site-settings", Astro.url), {
		headers: Astro.request.headers
	}),
	fetch(new URL("/api/games", Astro.url), {
		headers: Astro.request.headers
	})
]);

const currentPayload = currentResponse.ok ? await currentResponse.json() : { current: null };
const currentGame = (currentPayload.current as Game | null) ?? null;
const pollState = pollResponse.ok ? await pollResponse.json() : null;
const settingsPayload = settingsResponse.ok ? await settingsResponse.json() : { next_meeting: null };
const nextMeeting = typeof settingsPayload.next_meeting === "string" ? settingsPayload.next_meeting : null;
const gamesPayload = gamesResponse.ok
	? await gamesResponse.json()
	: { backlog: [], current: null, played: [] };
const backlogGames = gamesPayload.backlog as Game[];
const playedGames = gamesPayload.played as Game[];

function formatUsd(value?: number) {
	if (typeof value !== "number") return "TBD";
	return new Intl.NumberFormat("en-US", {
		style: "currency",
		currency: "USD"
	}).format(value / 100);
}

function firstName(value?: string) {
	if (!value) return "";
	return value.trim().split(/\s+/)[0] || "";
}

function getSubmitterLabel(game?: Game | null) {
	if (!game) return "Submitted by a member";
	const submitter = getSubmitter(game);
	return submitter ? `Submitted by ${submitter}` : "Submitted by a member";
}

function formatTtbHours(minutes?: number) {
	if (typeof minutes !== "number" || minutes <= 0) return null;
	const hours = minutes / 60;
	const rounded = Math.round(hours * 10) / 10;
	const text = rounded % 1 === 0 ? String(Math.trunc(rounded)) : String(rounded);
	return `${text} Hours`;
}

function formatTimeToBeat(minutes?: number | null) {
	if (!minutes && minutes !== 0) return "-";
	const hours = Math.floor(minutes / 60);
	const mins = Math.round(minutes % 60);
	return `${String(hours).padStart(2, "0")}:${String(mins).padStart(2, "0")}`;
}

function getSubmitter(game: Game) {
	return game.submitted_by_alias || firstName(game.submitted_by_name) || "Member";
}

const meetingLabel = nextMeeting ? "Next meeting: Loading..." : "Next meeting: TBD";
---

<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<meta name="generator" content={Astro.generator} />
		<meta
			name="description"
			content="Video game club."
		/>
		<title>Game Club</title>
	</head>
	<body>
		<AppHeader />

		<main>
			<div class="container">
			<section class="hero centered">
				<div class="hero-text">
					<p class="eyebrow">Monthly(ish) Video Game Club</p>
						<h1>Dusting off the library one month at a time</h1>
					<p class="lead" id="next-meeting" data-iso={nextMeeting || ""}>
						{meetingLabel}
					</p>
				</div>
			</section>

				<section class="section current-game two-column-grid">
				<div>
					{currentGame ? (
						<div class="card current-game-card">
							<div class="game-cover">
								{currentGame.cover_art_url ? (
									<img
										src={currentGame.cover_art_url}
										alt={`${currentGame.title} cover art`}
										loading="lazy"
									/>
								) : (
									<div class="cover-placeholder">Cover coming soon</div>
								)}
							</div>
							<h4 class="game-title">Current Game: {currentGame.title}</h4>
								{(() => {
									const tags = currentGame.tags_json
										? JSON.parse(currentGame.tags_json).join(" · ")
										: "Tags coming soon";
									const ttb = formatTtbHours(currentGame.time_to_beat_minutes);
									return (
										<p class="meta-line tight">
											{ttb ? `${ttb} | ${tags}` : tags}
										</p>
									);
								})()}
							<p class="current-game-description">
								{currentGame.description || "Description coming soon."}
							</p>
							<div class="game-detail-links">
								{currentGame.steam_app_id ? (
									<a
										class="ghost small-pill"
										target="_blank"
										rel="noreferrer"
										title="View on Steam"
										href={`https://store.steampowered.com/app/${currentGame.steam_app_id}`}
									>
										Steam
									</a>
								) : null}
								<a
									class="ghost small-pill"
									target="_blank"
									rel="noreferrer"
									title="View on HowLongToBeat"
									href={`https://howlongtobeat.com/?q=${encodeURIComponent(currentGame.title)}`}
								>
									HLTB
								</a>
								{currentGame.itad_slug ? (
									<a
										class="ghost small-pill"
										target="_blank"
										rel="noreferrer"
										title="View on IsThereAnyDeal"
										href={`https://isthereanydeal.com/game/${currentGame.itad_slug}/info/`}
									>
									ITAD
								</a>
							) : null}
							</div>
							<p class="meta-line">
								Current low: {formatUsd(currentGame.current_price_cents)} · Historical
								low: {formatUsd(currentGame.best_price_cents)}
							</p>
							<p class="muted small">{getSubmitterLabel(currentGame)}</p>
						</div>
					) : (
						<p class="muted">No current game set yet.</p>
					)}
				</div>
				<div class="card poll-summary" id="poll-summary">
					<div class="poll-summary-header">
						<div class="poll-header">
							<h3>Poll</h3>
							<span class="poll-status-text hidden" id="poll-chip">Inactive</span>
						</div>
						<div class="poll-summary-actions">
							<button class="cta" type="button" data-action="start-poll">Start a poll</button>
						</div>
					</div>
					<p class="muted" id="poll-status">Loading poll status...</p>
					<form class="poll-vote-form hidden" id="poll-vote-form">
						<div class="poll-vote-list">
							<div class="field">
								<label for="poll-choice-1">First choice</label>
								<select id="poll-choice-1" name="choice1">
									<option value="">Select a game</option>
								</select>
							</div>
							<div class="field">
								<label for="poll-choice-2">Second choice</label>
								<select id="poll-choice-2" name="choice2">
									<option value="">Optional</option>
								</select>
							</div>
							<div class="field">
								<label for="poll-choice-3">Third choice</label>
								<select id="poll-choice-3" name="choice3">
									<option value="">Optional</option>
								</select>
							</div>
						</div>
						<p class="poll-error hidden" id="poll-error" role="alert"></p>
						<div class="poll-vote-actions">
							<button class="cta" type="submit">Vote</button>
						</div>
					</form>
					<div class="poll-results" id="poll-results"></div>
					<p class="muted small" id="poll-meta"></p>
					<div class="poll-footer-actions">
						<button class="ghost danger hidden" type="button" data-action="close-poll">
							Close poll
						</button>
					</div>
					</div>
				</section>

					<section class="section">
						<div class="section-head">
							<h2>Backlog</h2>
							<button class="cta add-game hidden" type="button">Add a game</button>
						</div>
						<p class="form-error hidden" id="backlog-feedback" role="alert"></p>
						<div class="table-wrapper">
						<table class="games-table">
							<thead>
								<tr>
									<th data-sort="title" class="sortable">Title</th>
									<th data-sort="submitter" class="sortable">Submitter</th>
									<th data-sort="ttb" class="sortable">Time to beat</th>
									<th data-sort="current" class="sortable">Current low</th>
								</tr>
							</thead>
							<tbody>
								{backlogGames.map((game) => (
										<tr
											class="game-row clickable-row"
											data-id={game.id}
											data-title={game.title}
											data-title-sort={game.title.toLowerCase()}
											data-submitter={getSubmitter(game)}
											data-submitter-sort={getSubmitter(game).toLowerCase()}
											data-ttb={
												typeof game.time_to_beat_minutes === "number"
													? String(game.time_to_beat_minutes)
													: ""
											}
											data-ttb-minutes={
												typeof game.time_to_beat_minutes === "number"
													? String(game.time_to_beat_minutes)
													: ""
											}
											data-current-price={
												typeof game.current_price_cents === "number"
													? String(game.current_price_cents)
													: ""
											}
											data-best-price={
												typeof game.best_price_cents === "number"
													? String(game.best_price_cents)
													: ""
											}
											data-tags={game.tags_json || ""}
											data-description={game.description || ""}
											data-cover={game.cover_art_url || ""}
											data-submitted-name={game.submitted_by_name || ""}
											data-submitted-alias={game.submitted_by_alias || ""}
											data-steam-app-id={game.steam_app_id ? String(game.steam_app_id) : ""}
											data-itad-slug={game.itad_slug || ""}
											data-status={game.status}
										>
										<td>
											<div class="game-title-cell">
												<div class="game-icon">
													{game.itad_boxart_url || game.cover_art_url ? (
														<img src={game.itad_boxart_url || game.cover_art_url} alt="" loading="lazy" />
													) : (
														<span class="cover-placeholder">-</span>
													)}
												</div>
												<span class="game-title">{game.title}</span>
											</div>
										</td>
										<td class="muted">{getSubmitter(game)}</td>
										<td class="muted">{formatTimeToBeat(game.time_to_beat_minutes)}</td>
										<td class="muted">{formatUsd(game.current_price_cents)}</td>
									</tr>
								))}
							</tbody>
						</table>
					</div>
					<div class="row-tooltip" role="tooltip" aria-hidden="true">
						<div class="tooltip-description"></div>
						<div class="tooltip-tags"></div>
					</div>
				</section>

				<section class="section">
					<div class="section-head">
						<h2>Played</h2>
					</div>
					<div class="games-grid">
							{playedGames.map((game, index) => (
								<article
									class="game-card"
									style={`animation-delay: ${index * 70}ms`}
									data-id={game.id}
									data-title={game.title}
									data-tags={game.tags_json || ""}
									data-description={game.description || ""}
									data-cover={game.cover_art_url || ""}
									data-submitted-name={game.submitted_by_name || ""}
									data-submitted-alias={game.submitted_by_alias || ""}
									data-steam-app-id={game.steam_app_id ? String(game.steam_app_id) : ""}
									data-itad-slug={game.itad_slug || ""}
									data-current-price={
										typeof game.current_price_cents === "number"
											? String(game.current_price_cents)
										: ""
								}
								data-ttb-minutes={
									typeof game.time_to_beat_minutes === "number"
										? String(game.time_to_beat_minutes)
										: ""
								}
								data-best-price={
									typeof game.best_price_cents === "number"
										? String(game.best_price_cents)
										: ""
								}
								data-status={game.status}
							>
								<h3>{game.title}</h3>
								<div class="game-cover">
									{game.cover_art_url ? (
										<img
											src={game.cover_art_url}
											alt={`${game.title} cover art`}
											loading="lazy"
										/>
									) : (
										<div class="cover-placeholder">Cover coming soon</div>
									)}
								</div>
								<p class="muted">
									{game.tags_json ? JSON.parse(game.tags_json).join(" · ") : "Tags coming soon"}
								</p>
							</article>
						))}
					</div>
				</section>
				</div>
			</main>

		<AppFooter />
			<dialog class="modal" id="meeting-modal">
				<form class="modal-card meeting-form" novalidate>
				<header>
					<h3>Set next meeting</h3>
					<button class="ghost icon-button" type="button" data-action="close-meeting" aria-label="Close">
						×
					</button>
				</header>
				<div class="meeting-grid">
					<div class="field">
						<label for="meeting-date">Date</label>
						<input id="meeting-date" name="date" type="date" required />
					</div>
					<div class="field">
						<label for="meeting-time">Time</label>
						<input id="meeting-time" name="time" type="time" step="300" required />
					</div>
				</div>
				<p class="form-error hidden" id="meeting-error" role="alert"></p>
				<footer>
					<button class="ghost" type="button" data-action="close-meeting">Cancel</button>
					<button class="cta" type="submit">Save</button>
				</footer>
				</form>
			</dialog>
			<dialog class="modal" id="add-game-modal">
				<form class="modal-card add-game-form" novalidate>
					<header>
						<h3>Add a game</h3>
						<button class="ghost icon-button" type="button" data-action="close-add-game" aria-label="Close">
							×
						</button>
					</header>
					<div class="field">
						<label for="game-title">Game title</label>
						<input id="game-title" name="title" type="text" placeholder="Search for a game" autocomplete="off" required />
					</div>
					<ul class="suggestions" aria-live="polite" role="listbox"></ul>
					<p class="muted small">Start typing to see suggestions.</p>
					<p class="form-error hidden" id="add-game-error" role="alert"></p>
					<footer>
						<button class="ghost" type="button" data-action="close-add-game">Cancel</button>
						<button class="cta" type="submit">Submit</button>
					</footer>
				</form>
			</dialog>
			<dialog class="modal" id="game-detail-modal">
				<form class="modal-card game-detail-card" method="dialog">
					<header>
						<h3 class="game-detail-title">Game title</h3>
						<button class="ghost icon-button" type="button" data-action="close-game-detail" aria-label="Close">
							×
						</button>
					</header>
						<div class="game-detail-body">
							<img class="game-detail-cover" alt="" />
							<div class="game-detail-info">
							<p class="meta-line tight game-detail-tags"></p>
							<p class="game-detail-description"></p>
							<div class="game-detail-links">
								<a class="ghost small-pill game-detail-steam" target="_blank" rel="noreferrer" title="View on Steam">Steam</a>
								<a class="ghost small-pill game-detail-hltb" target="_blank" rel="noreferrer" title="View on HowLongToBeat">HLTB</a>
								<a class="ghost small-pill game-detail-itad" target="_blank" rel="noreferrer" title="View on IsThereAnyDeal">ITAD</a>
							</div>
							<div class="game-detail-ttb-edit hidden">
								<div class="field">
									<label for="game-detail-ttb">Time to beat (hours)</label>
									<div class="game-detail-ttb-row">
										<input id="game-detail-ttb" type="number" min="0" step="0.5" />
										<button class="ghost small-pill game-detail-ttb-save" type="button">Save TTB</button>
									</div>
								</div>
								<p class="form-error hidden game-detail-ttb-error" role="alert"></p>
							</div>
								<p class="meta-line tight game-detail-prices">Current low: TBD · Historical low: TBD</p>
								<p class="muted small game-detail-submitted"></p>
							</div>
						</div>
						<p class="form-error hidden game-detail-action-error" role="alert"></p>
						<footer class="game-detail-footer">
							<button class="ghost" type="button" data-action="close-game-detail">Close</button>
						<button class="ghost game-detail-set-current hidden" type="button">Set current</button>
						<button class="ghost danger game-detail-delete hidden" type="button">Delete</button>
					</footer>
				</form>
			</dialog>
			<script define:vars={{ initialPollState: pollState ?? null }}>
			const pollChip = document.querySelector("#poll-chip");
			const pollStatus = document.querySelector("#poll-status");
			const pollResults = document.querySelector("#poll-results");
			const pollMeta = document.querySelector("#poll-meta");
			const pollVoteForm = document.querySelector("#poll-vote-form");
			const pollChoice1 = document.querySelector("#poll-choice-1");
			const pollChoice2 = document.querySelector("#poll-choice-2");
			const pollChoice3 = document.querySelector("#poll-choice-3");
			const pollError = document.querySelector("#poll-error");
			const startButton = document.querySelector("[data-action='start-poll']");
			const closeButton = document.querySelector("[data-action='close-poll']");
			const meetingNode = document.querySelector("#next-meeting");
			const meetingModal = document.querySelector("#meeting-modal");
			const meetingDate = document.querySelector("#meeting-date");
			const meetingTime = document.querySelector("#meeting-time");
			const meetingError = document.querySelector("#meeting-error");
			let isAuthenticated = false;
			let isAdmin = false;
			let currentPollState = initialPollState;

			function formatPollDate(value) {
				if (!value) return "TBD";
				const normalized = value.includes("T") ? value : value.replace(" ", "T") + "Z";
				const date = new Date(normalized);
				if (Number.isNaN(date.getTime())) return value;
				return date.toLocaleDateString("en-US", {
					month: "short",
					day: "numeric",
					year: "numeric"
				});
			}

			function clearElement(element) {
				if (!element) return;
				while (element.firstChild) {
					element.removeChild(element.firstChild);
				}
			}

			function setButtonVisibility({ canStart, canVote, canClose }) {
				if (startButton) startButton.classList.toggle("hidden", !canStart);
				if (closeButton) closeButton.classList.toggle("hidden", !canClose);
			}

			function renderResults(results, label) {
				if (!pollResults) return;
				clearElement(pollResults);
				if (label === null) {
					return;
				}
				if (!results || results.length === 0) {
					const empty = document.createElement("p");
					empty.className = "muted small";
					empty.textContent = label || "No results yet.";
					pollResults.appendChild(empty);
					return;
				}
				const list = document.createElement("ol");
				list.className = "poll-results-list";
				results.forEach((result, index) => {
					const item = document.createElement("li");
					item.className = "poll-result";

					const title = document.createElement("span");
					title.className = "poll-result-title";
					title.textContent = `${index + 1}. ${result.title}`;

					const points = document.createElement("span");
					points.className = "poll-result-points";
					points.textContent = `${result.points ?? 0} pts`;

					item.appendChild(title);
					item.appendChild(points);
					list.appendChild(item);
				});
				pollResults.appendChild(list);
			}

			function renderPoll(state) {
				if (!pollStatus || !pollChip || !pollMeta) return;

				if (!state) {
					pollChip.textContent = "Offline";
					pollChip.classList.remove("hidden");
					pollStatus.textContent = "Unable to load poll status.";
					pollMeta.textContent = "";
					renderResults([], "No poll data available.");
					setButtonVisibility({ canStart: false, canVote: false, canClose: false });
					return;
				}

				if (state.active) {
					pollChip.textContent = "Voting live!";
					pollChip.classList.add("is-active");
					pollChip.classList.remove("hidden");
					pollStatus.textContent = state.hasVoted ? "Current standings:" : "";
					pollMeta.textContent = `Started ${formatPollDate(state.poll?.started_at)}`;
					if (!isAuthenticated) {
						renderResults([], "Sign in to vote.");
						setButtonVisibility({ canStart: false, canVote: false, canClose: false });
						toggleVoteForm(false);
					} else if (state.hasVoted) {
						renderResults(state.results || [], "Results will appear after votes land.");
						setButtonVisibility({ canStart: false, canVote: false, canClose: true });
						toggleVoteForm(false);
					} else {
						renderResults([], null);
						setButtonVisibility({ canStart: false, canVote: false, canClose: false });
						toggleVoteForm(true);
					}
				} else {
					pollChip.textContent = "Inactive";
					pollChip.classList.remove("is-active");
					pollChip.classList.add("hidden");
					pollStatus.textContent = "";
					pollMeta.textContent = state.poll
						? `Results from: ${formatPollDate(state.poll.closed_at || state.poll.started_at)} · Inactive`
						: "No polls yet.";
					renderResults(state.results || [], "No poll results yet.");
					setButtonVisibility({
						canStart: isAuthenticated,
						canVote: false,
						canClose: false
					});
					toggleVoteForm(false);
				}
			}

			function populateChoices(choices) {
				const selects = [pollChoice1, pollChoice2, pollChoice3];
				const sortedChoices = Array.isArray(choices)
					? [...choices].sort((a, b) => (a.title || "").localeCompare(b.title || ""))
					: [];
				selects.forEach((select) => {
					if (!select) return;
					const placeholder = select.querySelector("option");
					clearElement(select);
					if (placeholder) {
						select.appendChild(placeholder);
					}
					sortedChoices.forEach((choice) => {
						const option = document.createElement("option");
						option.value = String(choice.id);
						option.textContent = choice.title;
						select.appendChild(option);
					});
				});
			}

			function toggleVoteForm(show) {
				if (!pollVoteForm) return;
				pollVoteForm.classList.toggle("hidden", !show);
				const selects = [pollChoice1, pollChoice2, pollChoice3];
				selects.forEach((select) => {
					if (!select) return;
					select.disabled = !show;
				});
				if (!show) {
					selects.forEach((select) => {
						if (select) select.value = "";
					});
					setPollError("");
				}
			}

			function setPollError(message) {
				if (!pollError) return;
				if (message) {
					pollError.textContent = message;
					pollError.classList.remove("hidden");
				} else {
					pollError.textContent = "";
					pollError.classList.add("hidden");
				}
			}

			async function loadPollState() {
				const response = await fetch("/api/polls");
				if (!response.ok) {
					renderPoll(null);
					return null;
				}
				const data = await response.json();
				currentPollState = data;
				renderPoll(data);
				return data;
			}

			async function ensureAuthenticated(actionLabel) {
				const response = await fetch("/api/me");
				if (response.ok) return true;
				if (actionLabel) {
					pollStatus.textContent = `${actionLabel} requires signing in.`;
				}
				window.location.href = "/api/auth/login";
				return false;
			}

			async function startPoll() {
				const authed = await ensureAuthenticated("Starting a poll");
				if (!authed) return;
				const response = await fetch("/api/polls", { method: "POST" });
				if (response.ok) {
					const updated = await loadPollState();
					if (updated?.active) {
						populateChoices(updated.choices || []);
					}
				} else {
					const message = await response.text();
					pollStatus.textContent = message || "Unable to start poll.";
				}
			}

			async function closePoll() {
				const authed = await ensureAuthenticated("Closing the poll");
				if (!authed) return;
				const confirmed = window.confirm(
					"Close this poll now? Please confirm all votes are in before closing."
				);
				if (!confirmed) return;
				const response = await fetch("/api/polls", {
					method: "PATCH",
					headers: { "Content-Type": "application/json" },
					body: JSON.stringify({ action: "close" })
				});
				if (response.ok) {
					await loadPollState();
				} else {
					const message = await response.text();
					pollStatus.textContent = message || "Unable to close poll.";
				}
			}

			if (startButton) {
				startButton.addEventListener("click", () => startPoll());
			}

			if (closeButton) {
				closeButton.addEventListener("click", () => closePoll());
			}

			if (pollVoteForm) {
				pollVoteForm.addEventListener("submit", async (event) => {
					event.preventDefault();
					const choices = [pollChoice1, pollChoice2, pollChoice3]
						.map((select) => (select ? select.value : ""))
						.filter(Boolean)
						.map((value) => Number.parseInt(value, 10))
						.filter((value) => Number.isInteger(value));

					if (choices.length === 0) {
						setPollError("Pick at least one game.");
						return;
					}
					const unique = new Set(choices);
					if (unique.size !== choices.length) {
						setPollError("Each choice must be unique.");
						return;
					}

					const response = await fetch("/api/polls/vote", {
						method: "POST",
						headers: { "Content-Type": "application/json" },
						body: JSON.stringify({ choices })
					});

					if (response.ok) {
						const updated = await loadPollState();
						if (updated?.active) {
							populateChoices(updated.choices || []);
						}
					} else if (response.status === 401) {
						window.location.href = "/api/auth/login";
					} else {
						const message = await response.text();
						setPollError(message || "Unable to submit vote.");
					}
				});
			}

			if (initialPollState?.active && !initialPollState?.hasVoted) {
				populateChoices(initialPollState?.choices || []);
			}
			renderPoll(initialPollState);

			fetch("/api/me")
				.then((response) => {
					if (response.ok) {
						return response.json();
					}
				})
				.then((data) => {
					if (!data) return;
					isAuthenticated = true;
					isAdmin = data.role === "admin";
					if (meetingNode && isAdmin) {
						meetingNode.classList.add("editable");
						meetingNode.title = "Click to edit next meeting";
					}
				})
				.finally(() => {
					renderPoll(currentPollState);
				});

			if (meetingNode) {
				meetingNode.textContent = formatMeetingLocal(meetingNode.dataset.iso || "");
			}

			if (meetingNode) {
				meetingNode.addEventListener("click", async () => {
					if (!isAdmin) return;
					populateMeetingForm(meetingNode.dataset.iso || "");
					if (meetingError) {
						meetingError.textContent = "";
						meetingError.classList.add("hidden");
					}
					meetingModal?.showModal();
				});
			}

			function populateMeetingForm(isoValue) {
				if (!meetingDate || !meetingTime) return;
				const parts = getMeetingParts(isoValue);
				meetingDate.value = parts.date;
				meetingTime.value = parts.time;
			}

			function getMeetingParts(isoValue) {
				if (!isoValue) {
					return { date: "", time: "20:15" };
				}
				const date = new Date(isoValue);
				if (Number.isNaN(date.getTime())) {
					return { date: "", time: "20:15" };
				}
				const formatter = new Intl.DateTimeFormat("en-US", {
					year: "numeric",
					month: "2-digit",
					day: "2-digit",
					hour: "numeric",
					minute: "2-digit",
					hour12: true
				});
				const parts = formatter.formatToParts(date);
				const lookup = (type) => parts.find((part) => part.type === type)?.value;
				const year = lookup("year") || "";
				const month = lookup("month") || "";
				const day = lookup("day") || "";
				const hour = lookup("hour") || "8";
				const minute = lookup("minute") || "15";
				const dayPeriod = lookup("dayPeriod") || "PM";
				const hourNumber = Number.parseInt(hour, 10);
				let hour24 = Number.isNaN(hourNumber) ? 20 : hourNumber % 12;
				if (dayPeriod === "PM") hour24 += 12;
				const pad = (value) => String(value).padStart(2, "0");
				return { date: `${year}-${month}-${day}`, time: `${pad(hour24)}:${minute}` };
			}

			if (meetingModal) {
				meetingModal.addEventListener("click", (event) => {
					const target = event.target;
					if (!(target instanceof HTMLElement)) return;
					if (target.closest("[data-action='close-meeting']")) {
						if (meetingError) {
							meetingError.textContent = "";
							meetingError.classList.add("hidden");
						}
						meetingModal.close();
					}
				});
				meetingModal.addEventListener("submit", async (event) => {
					event.preventDefault();
					if (meetingError) {
						meetingError.textContent = "";
						meetingError.classList.add("hidden");
					}
					if (!meetingDate || !meetingTime) return;
					const dateValue = meetingDate.value;
					const timeValue = meetingTime.value;
					if (!dateValue || !timeValue) return;
					const [hourText, minuteText] = timeValue.split(":");
					const hour24 = Number.parseInt(hourText, 10);
					const minuteValue = Number.parseInt(minuteText, 10);
					if (Number.isNaN(hour24) || Number.isNaN(minuteValue)) return;
					const [year, month, day] = dateValue.split("-").map((val) => Number.parseInt(val, 10));
					const localDate = new Date(year, month - 1, day, hour24, minuteValue);
					if (Number.isNaN(localDate.getTime())) return;
					const response = await fetch("/api/site-settings", {
						method: "PATCH",
						headers: { "Content-Type": "application/json" },
						body: JSON.stringify({ next_meeting: localDate.toISOString() })
					});
					if (response.ok) {
						window.location.reload();
					} else if (meetingError) {
						const message = await response.text();
						meetingError.textContent = message || "Unable to update next meeting.";
						meetingError.classList.remove("hidden");
					}
				});
			}

				const addButton = document.querySelector(".add-game");
				const addModal = document.querySelector("#add-game-modal");
				const addForm = document.querySelector(".add-game-form");
				const addError = document.querySelector("#add-game-error");
				const titleInput = document.querySelector("#game-title");
				const suggestionList = document.querySelector(".suggestions");
				const detailModal = document.querySelector("#game-detail-modal");
				const detailTitle = document.querySelector(".game-detail-title");
				const detailTags = document.querySelector(".game-detail-tags");
				const detailDescription = document.querySelector(".game-detail-description");
				const detailSubmitted = document.querySelector(".game-detail-submitted");
				const detailCover = document.querySelector(".game-detail-cover");
				const detailDelete = document.querySelector(".game-detail-delete");
				const detailSetCurrent = document.querySelector(".game-detail-set-current");
				const detailSteam = document.querySelector(".game-detail-steam");
				const detailHltb = document.querySelector(".game-detail-hltb");
				const detailItad = document.querySelector(".game-detail-itad");
				const detailPrices = document.querySelector(".game-detail-prices");
				const detailTtbEdit = document.querySelector(".game-detail-ttb-edit");
				const detailTtbInput = document.querySelector("#game-detail-ttb");
				const detailTtbSave = document.querySelector(".game-detail-ttb-save");
				const detailTtbError = document.querySelector(".game-detail-ttb-error");
				const detailActionError = document.querySelector(".game-detail-action-error");
				const backlogFeedback = document.querySelector("#backlog-feedback");
				const tableBody = document.querySelector(".games-table tbody");
				const sortHeaders = document.querySelectorAll(".games-table th[data-sort]");
				const rowTooltip = document.querySelector(".row-tooltip");
				const tooltipDescription = rowTooltip?.querySelector(".tooltip-description");
				const tooltipTags = rowTooltip?.querySelector(".tooltip-tags");
				const steamIdKey = "steamAppId";
				let selectedGameId = null;
				let currentUserRole = "";
				let isSignedIn = false;

				function getFirstName(value) {
					if (!value) return "";
					return String(value).trim().split(/\s+/)[0] || "";
				}

				fetch("/api/me")
					.then((response) => {
						if (!response.ok) throw new Error("Not authenticated");
						if (addButton) addButton.classList.remove("hidden");
						isSignedIn = true;
						return response.json();
					})
					.then((data) => {
						if (data?.role) currentUserRole = String(data.role);
					})
					.catch(() => {});

				document.addEventListener("click", (event) => {
					const target = event.target;
					if (!(target instanceof HTMLElement)) return;
					if (target.closest(".add-game")) {
						if (!isSignedIn) {
							window.location.href = "/api/auth/login";
							return;
						}
						clearFormError();
						addModal?.showModal();
					}
					if (target.closest("[data-action='close-add-game']")) {
						addModal?.close();
					}
					if (target.closest("[data-action='close-game-detail']")) {
						detailModal?.close();
					}
					const selected = target.closest(".suggestion-item");
					if (selected && titleInput) {
						applySuggestion(selected);
					}
					const card = target.closest(".game-card");
					if (card && detailModal) {
						openGameDetail(card);
					}
					const row = target.closest(".game-row");
					if (row && detailModal) {
						openGameDetail(row);
					}
				});

				document.addEventListener("keydown", (event) => {
					const target = event.target;
					if (!(target instanceof HTMLElement)) return;
					if (!target.classList.contains("suggestion-item")) return;
					if (event.key !== "Enter" && event.key !== " ") return;
					event.preventDefault();
					applySuggestion(target);
				});

				const tableRows = tableBody
					? Array.from(tableBody.querySelectorAll(".game-row"))
					: [];

				if (addForm) {
					addForm.addEventListener("submit", async (event) => {
						event.preventDefault();
						const title = titleInput?.value.trim();
						if (!title) return;
						const steamAppId = titleInput?.dataset[steamIdKey];
						const response = await fetch("/api/games", {
							method: "POST",
							headers: { "Content-Type": "application/json" },
							body: JSON.stringify({ title, steamAppId })
						});
						if (response.ok) {
							addModal?.close();
							window.location.reload();
							return;
						}
						const message = await response.text();
						showFormError(message || "Unable to add game.");
					});
				}

				bindSearch(titleInput, suggestionList);

				function getRowValue(row, key) {
					if (key === "title") return row.dataset.titleSort || "";
					if (key === "submitter") return row.dataset.submitterSort || "";
					if (key === "ttb") return Number.parseInt(row.dataset.ttb || "0", 10);
					if (key === "current") return Number.parseInt(row.dataset.currentPrice || "0", 10);
					return "";
				}

				function compareRows(a, b, key, direction) {
					const dir = direction === "desc" ? -1 : 1;
					const aValue = getRowValue(a, key);
					const bValue = getRowValue(b, key);
					if (typeof aValue === "number" && typeof bValue === "number") {
						const aScore = aValue || Number.MAX_SAFE_INTEGER;
						const bScore = bValue || Number.MAX_SAFE_INTEGER;
						return (aScore - bScore) * dir;
					}
					return String(aValue).localeCompare(String(bValue)) * dir;
				}

				function applySort(key, direction) {
					if (!tableBody) return;
					const sorted = [...tableRows].sort((a, b) => compareRows(a, b, key, direction));
					sorted.forEach((row) => tableBody.appendChild(row));
				}

				sortHeaders.forEach((header) => {
					header.addEventListener("click", () => {
						const key = header.dataset.sort;
						if (!key) return;
						const current = header.dataset.direction || "asc";
						const nextDirection = current === "asc" ? "desc" : "asc";
						sortHeaders.forEach((th) => {
							delete th.dataset.direction;
						});
						header.dataset.direction = nextDirection;
						applySort(key, nextDirection);
					});
				});

				applySort("title", "asc");

				if (rowTooltip && tooltipDescription && tooltipTags && tableRows.length > 0) {
					let activeRow = null;

					function parseTagList(value) {
						if (!value) return [];
						try {
							const parsed = JSON.parse(value);
							return Array.isArray(parsed) ? parsed.filter(Boolean) : [];
						} catch {
							return [];
						}
					}

					function setTooltipContent(row) {
						const description = row.dataset.description?.trim() || "";
						const tags = parseTagList(row.dataset.tags || "");
						if (!description && tags.length === 0) {
							rowTooltip.classList.remove("visible");
							rowTooltip.setAttribute("aria-hidden", "true");
							return false;
						}
						tooltipDescription.textContent = description || "No description available.";
						tooltipDescription.classList.toggle("muted", !description);
						tooltipDescription.classList.toggle("small", !description);
						tooltipTags.textContent = tags.length ? tags.join(" • ") : "";
						rowTooltip.classList.add("visible");
						rowTooltip.setAttribute("aria-hidden", "false");
						return true;
					}

					function positionTooltip(event) {
						const offset = 16;
						const width = rowTooltip.offsetWidth;
						const height = rowTooltip.offsetHeight;
						let x = event.clientX + offset;
						let y = event.clientY + offset;
						if (x + width > window.innerWidth - 12) {
							x = event.clientX - width - offset;
						}
						if (y + height > window.innerHeight - 12) {
							y = event.clientY - height - offset;
						}
						rowTooltip.style.left = `${Math.max(12, x)}px`;
						rowTooltip.style.top = `${Math.max(12, y)}px`;
					}

					tableRows.forEach((row) => {
						row.addEventListener("mouseenter", (event) => {
							activeRow = row;
							const shouldShow = setTooltipContent(row);
							if (shouldShow) positionTooltip(event);
						});
						row.addEventListener("mousemove", (event) => {
							if (activeRow !== row || !rowTooltip.classList.contains("visible")) return;
							positionTooltip(event);
						});
						row.addEventListener("mouseleave", () => {
							if (activeRow !== row) return;
							activeRow = null;
							rowTooltip.classList.remove("visible");
							rowTooltip.setAttribute("aria-hidden", "true");
						});
					});
				}

				if (detailDelete) {
					detailDelete.addEventListener("click", async () => {
						if (!selectedGameId) return;
						const confirmed = window.confirm("Delete this game? This cannot be undone.");
						if (!confirmed) return;
						const response = await fetch("/api/games", {
							method: "DELETE",
							headers: { "Content-Type": "application/json" },
							body: JSON.stringify({ id: selectedGameId })
						});
						if (response.ok) {
							detailModal?.close();
							window.location.reload();
						} else if (detailActionError) {
							const message = await response.text();
							detailActionError.textContent = message || "Unable to delete game.";
							detailActionError.classList.remove("hidden");
						}
					});
				}

				if (detailTtbSave) {
					detailTtbSave.addEventListener("click", async () => {
						if (!selectedGameId || !detailTtbInput) return;
						const hoursValue = detailTtbInput.value.trim();
						const parsed = Number.parseFloat(hoursValue);
						if (!hoursValue || Number.isNaN(parsed) || parsed < 0) {
							if (detailTtbError) {
								detailTtbError.textContent = "Enter a valid number of hours.";
								detailTtbError.classList.remove("hidden");
							}
							return;
						}
						const response = await fetch("/api/games/ttb", {
							method: "POST",
							headers: { "Content-Type": "application/json" },
							body: JSON.stringify({
								id: Number.parseInt(String(selectedGameId), 10),
								time_to_beat_hours: parsed
							})
						});
						if (response.ok) {
							detailModal?.close();
							window.location.reload();
						} else if (detailTtbError) {
							detailTtbError.textContent = "Unable to save time to beat.";
							detailTtbError.classList.remove("hidden");
						}
					});
				}

				if (detailSetCurrent) {
					detailSetCurrent.addEventListener("click", async () => {
						if (!selectedGameId) return;
						const response = await fetch("/api/games", {
							method: "PATCH",
							headers: { "Content-Type": "application/json" },
							body: JSON.stringify({ id: selectedGameId, action: "set-current" })
						});
						if (response.ok) {
							detailModal?.close();
							window.location.reload();
						} else {
							const message = (await response.text()) || "Unable to set current game.";
							detailModal?.close();
							if (response.status === 404) {
								showBacklogFeedback("That game no longer exists. Refreshing list...");
								setTimeout(() => window.location.reload(), 1800);
								return;
							}
							showBacklogFeedback(message);
						}
					});
				}

				function bindSearch(input, list) {
					if (!input || !list) return;
					let searchTimer;
					input.addEventListener("input", () => {
						clearFormError();
						if (input === titleInput) {
							input.dataset[steamIdKey] = "";
						}
						const value = input.value.trim();
						if (searchTimer) clearTimeout(searchTimer);
						if (!value) {
							clearSuggestions(list);
							return;
						}
						searchTimer = setTimeout(async () => {
							const response = await fetch(`/api/games/search?term=${encodeURIComponent(value)}`);
							if (!response.ok) {
								renderSuggestions(list, []);
								return;
							}
							const data = await response.json();
							renderSuggestions(list, data.results || []);
						}, 300);
					});
				}

				function showFormError(message) {
					if (!addError) return;
					addError.textContent = message;
					addError.classList.remove("hidden");
				}

				function clearFormError() {
					if (!addError) return;
					addError.textContent = "";
					addError.classList.add("hidden");
				}

				function showBacklogFeedback(message) {
					if (!backlogFeedback) return;
					backlogFeedback.textContent = message;
					backlogFeedback.classList.remove("hidden");
				}

				function renderSuggestions(list, items) {
					if (!list) return;
					list.innerHTML = "";
					if (items.length === 0) {
						const empty = document.createElement("li");
						empty.className = "muted small";
						empty.textContent = "No matches yet.";
						list.appendChild(empty);
						return;
					}
					items.forEach((item) => {
						const entry = document.createElement("li");
						entry.className = "suggestion-item";
						entry.textContent = item.name;
						entry.dataset.name = item.name;
						if (item.steamId) {
							entry.dataset.steamId = String(item.steamId);
						}
						entry.setAttribute("role", "option");
						entry.tabIndex = 0;
						list.appendChild(entry);
					});
				}

				function clearSuggestions(list) {
					if (!list) return;
					list.innerHTML = "";
				}

				function applySuggestion(selected) {
					if (!titleInput) return;
					titleInput.value = selected?.dataset.name || selected?.textContent || "";
					titleInput.dataset[steamIdKey] = selected?.dataset.steamId || "";
					clearSuggestions(suggestionList);
					titleInput.focus();
				}

				function openGameDetail(card) {
					if (!detailModal) return;
					const title = card.dataset.title || "Untitled game";
					const description = card.dataset.description || "Description coming soon.";
					const tags = card.dataset.tags ? parseTags(card.dataset.tags) : "Tags coming soon";
					const submittedName = card.dataset.submittedName || "";
					const submittedAlias = card.dataset.submittedAlias || "";
					const cover = card.dataset.cover || "";
					const steamAppId = card.dataset.steamAppId || "";
					const itadSlug = card.dataset.itadSlug || "";
					const currentPrice = card.dataset.currentPrice || "";
					const bestPrice = card.dataset.bestPrice || "";
					const status = card.dataset.status || "";
					const ttbMinutes = card.dataset.ttbMinutes || "";
					selectedGameId = card.dataset.id || null;

					if (detailTitle) detailTitle.textContent = title;
					if (detailDescription) detailDescription.textContent = description;
					if (detailSubmitted) {
						const submitter = submittedAlias || getFirstName(submittedName) || "Member";
						detailSubmitted.textContent = `Submitted by ${submitter}`;
					}
					if (detailActionError) {
						detailActionError.classList.add("hidden");
						detailActionError.textContent = "";
					}
					if (detailCover) {
						if (cover) {
							detailCover.src = cover;
							detailCover.alt = title;
							detailCover.classList.remove("hidden");
						} else {
							detailCover.removeAttribute("src");
							detailCover.alt = "";
							detailCover.classList.add("hidden");
						}
					}
					if (detailSteam) {
						const steamUrl = steamAppId
							? `https://store.steampowered.com/app/${steamAppId}`
							: "";
						detailSteam.href = steamUrl;
						detailSteam.classList.toggle("hidden", !steamUrl);
					}
					if (detailHltb) {
						const hltbUrl = `https://howlongtobeat.com/?q=${encodeURIComponent(title)}`;
						detailHltb.href = hltbUrl;
						detailHltb.classList.toggle("hidden", !title);
					}
					if (detailItad) {
						const itadUrl = itadSlug
							? `https://isthereanydeal.com/game/${itadSlug}/info/`
							: "";
						detailItad.href = itadUrl;
						detailItad.classList.toggle("hidden", !itadUrl);
					}
					if (detailPrices) {
						detailPrices.textContent = `Current low: ${formatPriceForDetail(currentPrice)} · Historical low: ${formatPriceForDetail(bestPrice)}`;
					}
					if (detailTtbEdit) {
						const hasTtb = Boolean(ttbMinutes);
						detailTtbEdit.classList.toggle("hidden", hasTtb || !isSignedIn);
						if (detailTtbInput) detailTtbInput.value = "";
						if (detailTtbError) {
							detailTtbError.classList.add("hidden");
							detailTtbError.textContent = "";
						}
					}
					if (detailTags) {
						const tagLine = tags || "Tags coming soon";
						if (ttbMinutes) {
							detailTags.textContent = `${formatTtbHoursForDetail(ttbMinutes)} | ${tagLine}`;
						} else {
							detailTags.textContent = tagLine;
						}
					}
					if (detailDelete) {
						detailDelete.classList.toggle("hidden", !isSignedIn);
						if (isSignedIn) {
							detailDelete.disabled = false;
						}
					}
					if (detailSetCurrent) {
						const currentUserIsAdmin = currentUserRole === "admin";
						detailSetCurrent.classList.toggle("hidden", !currentUserIsAdmin);
						detailSetCurrent.disabled = status === "current";
					}

					detailModal.showModal();
				}

				function parseTags(value) {
					try {
						const parsed = JSON.parse(value);
						if (Array.isArray(parsed)) {
							return parsed.join(" · ");
						}
					} catch {}
					return value;
				}

				function formatTtbHoursForDetail(value) {
					const minutes = Number.parseFloat(String(value));
					if (!Number.isFinite(minutes) || minutes <= 0) return "0 Hours";
					const hours = minutes / 60;
					const rounded = Math.round(hours * 10) / 10;
					const text = rounded % 1 === 0 ? String(Math.trunc(rounded)) : String(rounded);
					return `${text} Hours`;
				}

				function formatPriceForDetail(value) {
					if (value === null || value === undefined || value === "") return "TBD";
					const cents = Number.parseInt(value, 10);
					if (Number.isNaN(cents)) return "TBD";
					return new Intl.NumberFormat("en-US", {
						style: "currency",
						currency: "USD"
					}).format(cents / 100);
				}

				function formatMeetingLocal(isoValue) {
					if (!isoValue) return "Next meeting: TBD";
				const date = new Date(isoValue);
				if (Number.isNaN(date.getTime())) return "Next meeting: TBD";
				const month = date.toLocaleString("en-US", { month: "long" });
				const day = date.getDate();
				const time = date.toLocaleString("en-US", {
					hour: "numeric",
					minute: "2-digit",
					hour12: true
				});
				return `Next meeting: ${month} ${formatOrdinal(day)} @ ${time}`;
			}

			function formatOrdinal(day) {
				if (day % 100 >= 11 && day % 100 <= 13) return `${day}th`;
				switch (day % 10) {
					case 1:
						return `${day}st`;
					case 2:
						return `${day}nd`;
					case 3:
						return `${day}rd`;
					default:
						return `${day}th`;
				}
			}
			</script>
		</body>
	</html>
