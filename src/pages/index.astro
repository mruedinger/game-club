---
import AppHeader from "../components/AppHeader.astro";
import AppFooter from "../components/AppFooter.astro";
import "../styles/base.css";

type Game = {
	id: number;
	title: string;
	status: "backlog" | "current" | "played";
	tags_json?: string;
	played_month?: string;
	cover_art_url?: string;
	description?: string;
	submitted_by_email?: string;
	submitted_by_name?: string;
	submitted_by_alias?: string;
	steam_app_id?: number;
	itad_slug?: string;
	current_price_cents?: number;
	best_price_cents?: number;
};

const [currentResponse, pollResponse, settingsResponse] = await Promise.all([
	fetch(new URL("/api/games/current", Astro.url), {
		headers: Astro.request.headers
	}),
	fetch(new URL("/api/polls", Astro.url), {
		headers: Astro.request.headers
	}),
	fetch(new URL("/api/site-settings", Astro.url), {
		headers: Astro.request.headers
	})
]);

const currentPayload = currentResponse.ok ? await currentResponse.json() : { current: null };
const currentGame = (currentPayload.current as Game | null) ?? null;
const pollState = pollResponse.ok ? await pollResponse.json() : null;
const settingsPayload = settingsResponse.ok ? await settingsResponse.json() : { next_meeting: null };
const nextMeeting = typeof settingsPayload.next_meeting === "string" ? settingsPayload.next_meeting : null;

function formatUsd(value?: number) {
	if (typeof value !== "number") return "TBD";
	return new Intl.NumberFormat("en-US", {
		style: "currency",
		currency: "USD"
	}).format(value / 100);
}

function getSubmitterLabel(game?: Game | null) {
	if (!game) return "Submitted by a member";
	const submitter =
		game.submitted_by_alias || game.submitted_by_name || game.submitted_by_email;
	return submitter ? `Submitted by ${submitter}` : "Submitted by a member";
}

const meetingLabel = nextMeeting ? "Next meeting: Loading..." : "Next meeting: TBD";
---

<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<meta name="generator" content={Astro.generator} />
		<meta
			name="description"
			content="Video game club."
		/>
		<title>Game Club</title>
	</head>
	<body>
		<AppHeader />

		<main>
			<div class="container">
			<section class="hero centered">
				<div class="hero-text">
					<p class="eyebrow">Monthly(ish) Video Game Club</p>
					<h1>A Shindigging good time</h1>
					<p class="lead" id="next-meeting" data-iso={nextMeeting || ""}>
						{meetingLabel}
					</p>
				</div>
			</section>

			<section class="section current-game two-column-grid">
				<div>
					{currentGame ? (
						<div class="card current-game-card">
							<div class="game-cover">
								{currentGame.cover_art_url ? (
									<img
										src={currentGame.cover_art_url}
										alt={`${currentGame.title} cover art`}
										loading="lazy"
									/>
								) : (
									<div class="cover-placeholder">Cover coming soon</div>
								)}
							</div>
							<h4 class="game-title">Current Game: {currentGame.title}</h4>
								{currentGame.tags_json ? (
									<p class="meta-line tight">
										{JSON.parse(currentGame.tags_json).join(" · ")}
									</p>
								) : (
									<p class="meta-line tight">Tags coming soon</p>
								)}
							<p class="current-game-description">
								{currentGame.description || "Description coming soon."}
							</p>
							<div class="game-detail-links">
								{currentGame.steam_app_id ? (
									<a
										class="ghost small-pill"
										target="_blank"
										rel="noreferrer"
										title="View on Steam"
										href={`https://store.steampowered.com/app/${currentGame.steam_app_id}`}
									>
										Steam
									</a>
								) : null}
								<a
									class="ghost small-pill"
									target="_blank"
									rel="noreferrer"
									title="View on HowLongToBeat"
									href={`https://howlongtobeat.com/?q=${encodeURIComponent(currentGame.title)}`}
								>
									HLTB
								</a>
								{currentGame.itad_slug ? (
									<a
										class="ghost small-pill"
										target="_blank"
										rel="noreferrer"
										title="View on IsThereAnyDeal"
										href={`https://isthereanydeal.com/game/${currentGame.itad_slug}/info/`}
									>
									ITAD
								</a>
							) : null}
							</div>
							<p class="meta-line">
								Current low: {formatUsd(currentGame.current_price_cents)} · Historical
								low: {formatUsd(currentGame.best_price_cents)}
							</p>
							<p class="muted small">{getSubmitterLabel(currentGame)}</p>
						</div>
					) : (
						<p class="muted">No current game set yet.</p>
					)}
				</div>
				<div class="card poll-summary" id="poll-summary">
					<div class="poll-summary-header">
						<div class="poll-header">
							<h3>Poll</h3>
							<span class="poll-status-text hidden" id="poll-chip">Inactive</span>
						</div>
						<div class="poll-summary-actions">
							<button class="cta" type="button" data-action="start-poll">Start a poll</button>
						</div>
					</div>
					<p class="muted" id="poll-status">Loading poll status...</p>
					<form class="poll-vote-form hidden" id="poll-vote-form">
						<div class="poll-vote-list">
							<div class="field">
								<label for="poll-choice-1">First choice</label>
								<select id="poll-choice-1" name="choice1">
									<option value="">Select a game</option>
								</select>
							</div>
							<div class="field">
								<label for="poll-choice-2">Second choice</label>
								<select id="poll-choice-2" name="choice2">
									<option value="">Optional</option>
								</select>
							</div>
							<div class="field">
								<label for="poll-choice-3">Third choice</label>
								<select id="poll-choice-3" name="choice3">
									<option value="">Optional</option>
								</select>
							</div>
						</div>
						<p class="poll-error hidden" id="poll-error" role="alert"></p>
						<div class="poll-vote-actions">
							<button class="cta" type="submit">Vote</button>
						</div>
					</form>
					<div class="poll-results" id="poll-results"></div>
					<p class="muted small" id="poll-meta"></p>
					<div class="poll-footer-actions">
						<button class="ghost danger hidden" type="button" data-action="close-poll">
							Close poll
						</button>
					</div>
				</div>
			</section>
			</div>
		</main>

		<AppFooter />
		<dialog class="modal" id="meeting-modal">
			<form class="modal-card meeting-form" novalidate>
				<header>
					<h3>Set next meeting</h3>
					<button class="ghost icon-button" type="button" data-action="close-meeting" aria-label="Close">
						×
					</button>
				</header>
				<div class="meeting-grid">
					<div class="field">
						<label for="meeting-date">Date</label>
						<input id="meeting-date" name="date" type="date" required />
					</div>
					<div class="field">
						<label for="meeting-hour">Hour</label>
						<input id="meeting-hour" name="hour" type="number" min="1" max="12" required />
					</div>
					<div class="field">
						<label for="meeting-minute">Minute</label>
						<input id="meeting-minute" name="minute" type="number" min="0" max="59" required />
					</div>
					<div class="field">
						<label for="meeting-ampm">AM/PM</label>
						<select id="meeting-ampm" name="ampm" required>
							<option value="AM">AM</option>
							<option value="PM">PM</option>
						</select>
					</div>
				</div>
				<footer>
					<button class="ghost" type="button" data-action="close-meeting">Cancel</button>
					<button class="cta" type="submit">Save</button>
				</footer>
			</form>
		</dialog>
		<script define:vars={{ initialPollState: pollState ?? null }}>
			const pollChip = document.querySelector("#poll-chip");
			const pollStatus = document.querySelector("#poll-status");
			const pollResults = document.querySelector("#poll-results");
			const pollMeta = document.querySelector("#poll-meta");
			const pollVoteForm = document.querySelector("#poll-vote-form");
			const pollChoice1 = document.querySelector("#poll-choice-1");
			const pollChoice2 = document.querySelector("#poll-choice-2");
			const pollChoice3 = document.querySelector("#poll-choice-3");
			const pollError = document.querySelector("#poll-error");
			const startButton = document.querySelector("[data-action='start-poll']");
			const closeButton = document.querySelector("[data-action='close-poll']");
			const meetingNode = document.querySelector("#next-meeting");
			const meetingModal = document.querySelector("#meeting-modal");
			const meetingDate = document.querySelector("#meeting-date");
			const meetingHour = document.querySelector("#meeting-hour");
			const meetingMinute = document.querySelector("#meeting-minute");
			const meetingAmPm = document.querySelector("#meeting-ampm");
			let isAuthenticated = false;
			let isAdmin = false;
			let currentPollState = initialPollState;

			function formatPollDate(value) {
				if (!value) return "TBD";
				const normalized = value.includes("T") ? value : value.replace(" ", "T") + "Z";
				const date = new Date(normalized);
				if (Number.isNaN(date.getTime())) return value;
				return date.toLocaleDateString("en-US", {
					month: "short",
					day: "numeric",
					year: "numeric"
				});
			}

			function clearElement(element) {
				if (!element) return;
				while (element.firstChild) {
					element.removeChild(element.firstChild);
				}
			}

			function setButtonVisibility({ canStart, canVote, canClose }) {
				if (startButton) startButton.classList.toggle("hidden", !canStart);
				if (closeButton) closeButton.classList.toggle("hidden", !canClose);
			}

			function renderResults(results, label) {
				if (!pollResults) return;
				clearElement(pollResults);
				if (label === null) {
					return;
				}
				if (!results || results.length === 0) {
					const empty = document.createElement("p");
					empty.className = "muted small";
					empty.textContent = label || "No results yet.";
					pollResults.appendChild(empty);
					return;
				}
				const list = document.createElement("ol");
				list.className = "poll-results-list";
				results.forEach((result, index) => {
					const item = document.createElement("li");
					item.className = "poll-result";

					const title = document.createElement("span");
					title.className = "poll-result-title";
					title.textContent = `${index + 1}. ${result.title}`;

					const points = document.createElement("span");
					points.className = "poll-result-points";
					points.textContent = `${result.points ?? 0} pts`;

					item.appendChild(title);
					item.appendChild(points);
					list.appendChild(item);
				});
				pollResults.appendChild(list);
			}

			function renderPoll(state) {
				if (!pollStatus || !pollChip || !pollMeta) return;

				if (!state) {
					pollChip.textContent = "Offline";
					pollChip.classList.remove("hidden");
					pollStatus.textContent = "Unable to load poll status.";
					pollMeta.textContent = "";
					renderResults([], "No poll data available.");
					setButtonVisibility({ canStart: false, canVote: false, canClose: false });
					return;
				}

				if (state.active) {
					pollChip.textContent = "Voting live!";
					pollChip.classList.add("is-active");
					pollChip.classList.remove("hidden");
					pollStatus.textContent = state.hasVoted ? "Current standings:" : "";
					pollMeta.textContent = `Started ${formatPollDate(state.poll?.started_at)}`;
					if (!isAuthenticated) {
						renderResults([], "Sign in to vote.");
						setButtonVisibility({ canStart: false, canVote: false, canClose: false });
						toggleVoteForm(false);
					} else if (state.hasVoted) {
						renderResults(state.results || [], "Results will appear after votes land.");
						setButtonVisibility({ canStart: false, canVote: false, canClose: true });
						toggleVoteForm(false);
					} else {
						renderResults([], null);
						setButtonVisibility({ canStart: false, canVote: false, canClose: false });
						toggleVoteForm(true);
					}
				} else {
					pollChip.textContent = "Inactive";
					pollChip.classList.remove("is-active");
					pollChip.classList.add("hidden");
					pollStatus.textContent = "";
					pollMeta.textContent = state.poll
						? `Results from: ${formatPollDate(state.poll.closed_at || state.poll.started_at)} · Inactive`
						: "No polls yet.";
					renderResults(state.results || [], "No poll results yet.");
					setButtonVisibility({
						canStart: isAuthenticated,
						canVote: false,
						canClose: false
					});
					toggleVoteForm(false);
				}
			}

			function populateChoices(choices) {
				const selects = [pollChoice1, pollChoice2, pollChoice3];
				const sortedChoices = Array.isArray(choices)
					? [...choices].sort((a, b) => (a.title || "").localeCompare(b.title || ""))
					: [];
				selects.forEach((select) => {
					if (!select) return;
					const placeholder = select.querySelector("option");
					clearElement(select);
					if (placeholder) {
						select.appendChild(placeholder);
					}
					sortedChoices.forEach((choice) => {
						const option = document.createElement("option");
						option.value = String(choice.id);
						option.textContent = choice.title;
						select.appendChild(option);
					});
				});
			}

			function toggleVoteForm(show) {
				if (!pollVoteForm) return;
				pollVoteForm.classList.toggle("hidden", !show);
				const selects = [pollChoice1, pollChoice2, pollChoice3];
				selects.forEach((select) => {
					if (!select) return;
					select.disabled = !show;
				});
				if (!show) {
					selects.forEach((select) => {
						if (select) select.value = "";
					});
					setPollError("");
				}
			}

			function setPollError(message) {
				if (!pollError) return;
				if (message) {
					pollError.textContent = message;
					pollError.classList.remove("hidden");
				} else {
					pollError.textContent = "";
					pollError.classList.add("hidden");
				}
			}

			async function loadPollState() {
				const response = await fetch("/api/polls");
				if (!response.ok) {
					renderPoll(null);
					return null;
				}
				const data = await response.json();
				currentPollState = data;
				renderPoll(data);
				return data;
			}

			async function ensureAuthenticated(actionLabel) {
				const response = await fetch("/api/me");
				if (response.ok) return true;
				if (actionLabel) {
					pollStatus.textContent = `${actionLabel} requires signing in.`;
				}
				window.location.href = "/api/auth/login";
				return false;
			}

			async function startPoll() {
				const authed = await ensureAuthenticated("Starting a poll");
				if (!authed) return;
				const response = await fetch("/api/polls", { method: "POST" });
				if (response.ok) {
					const updated = await loadPollState();
					if (updated?.active) {
						populateChoices(updated.choices || []);
					}
				} else {
					const message = await response.text();
					pollStatus.textContent = message || "Unable to start poll.";
				}
			}

			async function closePoll() {
				const authed = await ensureAuthenticated("Closing the poll");
				if (!authed) return;
				const confirmed = window.confirm(
					"Close this poll now? Please confirm all votes are in before closing."
				);
				if (!confirmed) return;
				const response = await fetch("/api/polls", {
					method: "PATCH",
					headers: { "Content-Type": "application/json" },
					body: JSON.stringify({ action: "close" })
				});
				if (response.ok) {
					await loadPollState();
				} else {
					const message = await response.text();
					pollStatus.textContent = message || "Unable to close poll.";
				}
			}

			if (startButton) {
				startButton.addEventListener("click", () => startPoll());
			}

			if (closeButton) {
				closeButton.addEventListener("click", () => closePoll());
			}

			if (pollVoteForm) {
				pollVoteForm.addEventListener("submit", async (event) => {
					event.preventDefault();
					const choices = [pollChoice1, pollChoice2, pollChoice3]
						.map((select) => (select ? select.value : ""))
						.filter(Boolean)
						.map((value) => Number.parseInt(value, 10))
						.filter((value) => Number.isInteger(value));

					if (choices.length === 0) {
						setPollError("Pick at least one game.");
						return;
					}
					const unique = new Set(choices);
					if (unique.size !== choices.length) {
						setPollError("Each choice must be unique.");
						return;
					}

					const response = await fetch("/api/polls/vote", {
						method: "POST",
						headers: { "Content-Type": "application/json" },
						body: JSON.stringify({ choices })
					});

					if (response.ok) {
						const updated = await loadPollState();
						if (updated?.active) {
							populateChoices(updated.choices || []);
						}
					} else if (response.status === 401) {
						window.location.href = "/api/auth/login";
					} else {
						const message = await response.text();
						setPollError(message || "Unable to submit vote.");
					}
				});
			}

			if (initialPollState?.active && !initialPollState?.hasVoted) {
				populateChoices(initialPollState?.choices || []);
			}
			renderPoll(initialPollState);

			fetch("/api/me")
				.then((response) => {
					if (response.ok) {
						return response.json();
					}
				})
				.then((data) => {
					if (!data) return;
					isAuthenticated = true;
					isAdmin = data.role === "admin";
					if (meetingNode && isAdmin) {
						meetingNode.classList.add("editable");
						meetingNode.title = "Click to edit next meeting";
					}
				})
				.finally(() => {
					renderPoll(currentPollState);
				});

			if (meetingNode) {
				meetingNode.textContent = formatMeetingLocal(meetingNode.dataset.iso || "");
			}

			if (meetingNode) {
				meetingNode.addEventListener("click", async () => {
					if (!isAdmin) return;
					populateMeetingForm(meetingNode.dataset.iso || "");
					meetingModal?.showModal();
				});
			}

			function populateMeetingForm(isoValue) {
				if (!meetingDate || !meetingHour || !meetingMinute || !meetingAmPm) return;
				const parts = getMeetingParts(isoValue);
				meetingDate.value = parts.date;
				meetingHour.value = parts.hour;
				meetingMinute.value = parts.minute;
				meetingAmPm.value = parts.ampm;
			}

			function getMeetingParts(isoValue) {
				if (!isoValue) {
					return { date: "", hour: "8", minute: "15", ampm: "PM" };
				}
				const date = new Date(isoValue);
				if (Number.isNaN(date.getTime())) {
					return { date: "", hour: "8", minute: "15", ampm: "PM" };
				}
				const formatter = new Intl.DateTimeFormat("en-US", {
					year: "numeric",
					month: "2-digit",
					day: "2-digit",
					hour: "numeric",
					minute: "2-digit",
					hour12: true
				});
				const parts = formatter.formatToParts(date);
				const lookup = (type) => parts.find((part) => part.type === type)?.value;
				const year = lookup("year") || "";
				const month = lookup("month") || "";
				const day = lookup("day") || "";
				const hour = lookup("hour") || "8";
				const minute = lookup("minute") || "15";
				const dayPeriod = lookup("dayPeriod") || "PM";
				return { date: `${year}-${month}-${day}`, hour, minute, ampm: dayPeriod };
			}

			if (meetingModal) {
				meetingModal.addEventListener("click", (event) => {
					const target = event.target;
					if (!(target instanceof HTMLElement)) return;
					if (target.closest("[data-action='close-meeting']")) {
						meetingModal.close();
					}
				});
				meetingModal.addEventListener("submit", async (event) => {
					event.preventDefault();
					if (!meetingDate || !meetingHour || !meetingMinute || !meetingAmPm) return;
					const dateValue = meetingDate.value;
					const hourValue = Number.parseInt(meetingHour.value, 10);
					const minuteValue = Number.parseInt(meetingMinute.value, 10);
					const ampmValue = meetingAmPm.value;
					if (!dateValue || !hourValue || Number.isNaN(minuteValue)) return;
					let hour24 = hourValue % 12;
					if (ampmValue === "PM") hour24 += 12;
					const [year, month, day] = dateValue.split("-").map((val) => Number.parseInt(val, 10));
					const localDate = new Date(year, month - 1, day, hour24, minuteValue);
					if (Number.isNaN(localDate.getTime())) return;
					const response = await fetch("/api/site-settings", {
						method: "PATCH",
						headers: { "Content-Type": "application/json" },
						body: JSON.stringify({ next_meeting: localDate.toISOString() })
					});
					if (response.ok) {
						window.location.reload();
					}
				});
			}

			function formatMeetingLocal(isoValue) {
				if (!isoValue) return "Next meeting: TBD";
				const date = new Date(isoValue);
				if (Number.isNaN(date.getTime())) return "Next meeting: TBD";
				const month = date.toLocaleString("en-US", { month: "long" });
				const day = date.getDate();
				const time = date.toLocaleString("en-US", {
					hour: "numeric",
					minute: "2-digit",
					hour12: true
				});
				return `Next meeting: ${month} ${formatOrdinal(day)} @ ${time}`;
			}

			function formatOrdinal(day) {
				if (day % 100 >= 11 && day % 100 <= 13) return `${day}th`;
				switch (day % 10) {
					case 1:
						return `${day}st`;
					case 2:
						return `${day}nd`;
					case 3:
						return `${day}rd`;
					default:
						return `${day}th`;
				}
			}
		</script>
	</body>
</html>

<style>
	:root {
		color-scheme: light;
		--ink: #1f2933;
		--muted: #5b6672;
		--cream: #eef2f6;
		--tan: #dbe2ea;
		--sun: #8bb5e1;
		--ink-soft: #364152;
		--shadow: rgba(13, 30, 48, 0.18);
		--border: rgba(33, 51, 70, 0.14);
		--accent: #3b6ea5;
		--accent-dark: #2a5581;
		--radius: 22px;
		font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
		background: radial-gradient(circle at top right, #f7fbff 0%, #eef2f6 55%, #e2e8f0 100%);
	}

	* {
		box-sizing: border-box;
	}

	body {
		margin: 0;
		color: var(--ink);
		background: linear-gradient(120deg, #f6f9fc 0%, #e9eff6 60%, #dde5ef 100%);
		min-height: 100vh;
		position: relative;
	}

	body::before {
		content: "";
		position: fixed;
		inset: 0;
		background: radial-gradient(circle at 10% 20%, rgba(255, 255, 255, 0.7) 0%, transparent 55%),
			radial-gradient(circle at 80% 10%, rgba(143, 179, 220, 0.4) 0%, transparent 50%),
			linear-gradient(160deg, rgba(255, 255, 255, 0.5) 0%, transparent 60%);
		pointer-events: none;
		z-index: -1;
	}

	a {
		color: inherit;
		text-decoration: none;
	}

	@media (max-width: 900px) {
		.site-header {
			flex-direction: column;
			gap: 1rem;
		}

		.site-nav {
			flex-wrap: wrap;
			justify-content: center;
		}

	}

	@media (max-width: 600px) {
		.header-actions {
			width: 100%;
			justify-content: center;
			flex-wrap: wrap;
		}
	}

	@keyframes rise {
		from {
			opacity: 0;
			transform: translateY(12px);
		}
		to {
			opacity: 1;
			transform: translateY(0);
		}
	}

	@media (prefers-reduced-motion: reduce) {
		* {
			animation: none !important;
			transition: none !important;
		}
	}
</style>
