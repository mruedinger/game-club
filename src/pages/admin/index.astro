---
import AppHeader from "../../components/AppHeader.astro";
import AppFooter from "../../components/AppFooter.astro";
import "../../styles/base.css";

export const prerender = false;
---

<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>Game Club | Admin</title>
	</head>
	<body>
		<AppHeader />

		<main class="admin-shell is-hidden">
			<div class="container">
				<section class="hero">
					<div class="hero-text">
						<p class="eyebrow">Admin</p>
						<h1>Control Room</h1>
						<p class="muted">Manage members, content, and club operations.</p>
					</div>
				</section>

				<section class="section card members-card">
					<div class="section-head">
						<h2>Members</h2>
						<p class="muted">View and manage member access.</p>
					</div>
					<button class="cta invite-cta" type="button" data-action="open-invite">
						Add a new member
					</button>
					<div class="table-wrapper scroll-rows" aria-live="polite">
						<table class="games-table member-table">
							<thead>
								<tr>
									<th>User</th>
									<th>Alias</th>
									<th>Email</th>
									<th>Role</th>
								</tr>
							</thead>
							<tbody class="member-list">
								<tr>
									<td class="muted small" colspan="4">Loading members…</td>
								</tr>
							</tbody>
						</table>
					</div>
				</section>

				<section class="section card games-editor">
					<div class="section-head">
						<h2>Games data editor</h2>
						<p class="muted">Edit submitters, status, tags, and timing details.</p>
					</div>
					<p class="muted small">Tags: comma-separated list (e.g. Narrative, Roguelike, Puzzle)</p>
					<div class="table-wrapper scroll-rows">
						<table class="games-table games-editor-table">
							<thead>
								<tr>
									<th data-sort="title" class="sortable">Title</th>
									<th data-sort="submitter" class="sortable">Submitter</th>
									<th data-sort="status" class="sortable">Status</th>
									<th data-sort="eligibility" class="sortable">Poll eligible</th>
									<th data-sort="tags" class="sortable">Tags</th>
									<th data-sort="ttb" class="sortable">Time to beat</th>
									<th data-sort="played" class="sortable">Played month</th>
								</tr>
							</thead>
							<tbody class="games-editor-body">
								<tr>
									<td class="muted small" colspan="7">Loading games…</td>
								</tr>
							</tbody>
						</table>
					</div>
				</section>

				<section class="section card poll-history-card">
					<div class="section-head">
						<h2>Poll History</h2>
						<p class="muted">Review closed polls and control validity for lifetime points.</p>
					</div>
					<div class="table-wrapper scroll-rows">
						<table class="games-table poll-history-table">
							<thead>
								<tr>
									<th>Poll date</th>
									<th>Winner</th>
									<th>Voter count</th>
									<th>Validity</th>
								</tr>
							</thead>
							<tbody class="poll-history-body">
								<tr>
									<td class="muted small" colspan="4">Loading poll history…</td>
								</tr>
							</tbody>
						</table>
					</div>
				</section>

				<section class="section card audit-card">
					<div class="section-head">
						<h2>Audit logs</h2>
						<p class="muted">Track recent administrative activity.</p>
					</div>
					<div class="table-wrapper scroll-rows">
						<table class="games-table audit-table">
							<thead>
								<tr>
									<th>When</th>
									<th>Actor</th>
									<th>Action</th>
									<th>Entity</th>
								</tr>
							</thead>
							<tbody class="audit-body">
								<tr>
									<td class="muted small" colspan="4">Loading activity…</td>
								</tr>
							</tbody>
						</table>
					</div>
				</section>
			</div>
		</main>
		<AppFooter />

		<dialog class="modal" id="invite-modal">
			<form method="dialog" class="modal-card invite-form" novalidate>
				<header>
					<h3>Add a new member</h3>
					<button class="ghost icon-button" type="button" data-action="close-invite" aria-label="Close">
						×
					</button>
				</header>
				<div class="field">
					<label for="invite-email">Email</label>
					<input id="invite-email" name="email" type="email" placeholder="name@example.com" required />
				</div>
				<div class="field">
					<label for="invite-role">Role</label>
					<select id="invite-role" name="role" required>
						<option value="member" selected>Member</option>
						<option value="admin">Admin</option>
					</select>
				</div>
				<p class="form-error hidden" id="invite-error" role="alert"></p>
				<footer>
					<button class="ghost" value="cancel" type="button" data-action="close-invite">Cancel</button>
					<button class="cta" type="submit">Submit</button>
				</footer>
			</form>
		</dialog>

		<dialog class="modal" id="member-modal">
			<form class="modal-card member-detail" novalidate>
				<header>
					<div>
						<h3 id="member-name">Member</h3>
						<p class="muted small" id="member-email">email@example.com</p>
					</div>
					<button class="ghost icon-button" type="button" data-action="close-member" aria-label="Close">
						×
					</button>
				</header>
				<div class="field">
					<label for="edit-role">Role</label>
					<select id="edit-role" name="role" required>
						<option value="member">Member</option>
						<option value="admin">Admin</option>
					</select>
				</div>
				<div class="field">
					<label for="edit-alias">Alias</label>
					<input id="edit-alias" name="alias" type="text" placeholder="Optional" />
				</div>
				<div class="actions">
					<button class="ghost danger small-button" data-action="delete" type="button">Delete member</button>
				</div>
				<p class="form-error hidden" id="member-modal-error" role="alert"></p>
				<footer>
					<button class="ghost" type="button" data-action="close-member">Cancel</button>
					<button class="cta" type="submit">Submit</button>
				</footer>
			</form>
		</dialog>

		<dialog class="modal" id="game-modal">
			<form class="modal-card game-detail" novalidate>
				<header>
					<div>
						<h3 id="game-modal-title">Game</h3>
						<p class="muted small" id="game-modal-subtitle"></p>
					</div>
					<button class="ghost icon-button" type="button" data-action="close-game" aria-label="Close">
						×
					</button>
				</header>
				<div class="field">
					<label for="edit-game-submitter">Submitter</label>
					<select id="edit-game-submitter" name="submitted_by_email" required></select>
				</div>
				<div class="field">
					<label for="edit-game-status">Status</label>
					<select id="edit-game-status" name="status" required>
						<option value="backlog">backlog</option>
						<option value="current">current</option>
						<option value="played">played</option>
					</select>
				</div>
				<div class="field">
					<label class="toggle-control" for="edit-game-eligibility">
						<span>Poll eligible</span>
						<span class="toggle-switch">
							<input id="edit-game-eligibility" name="poll_eligible" type="checkbox" />
							<span class="toggle-slider"></span>
						</span>
					</label>
					<p class="muted small" id="edit-game-eligibility-help">Select up to 2 backlog games per member.</p>
				</div>
				<div class="field">
					<label for="edit-game-tags">Tags</label>
					<input id="edit-game-tags" name="tags" type="text" placeholder="Narrative, Roguelike" />
				</div>
				<div class="field">
					<label for="edit-game-ttb">Time to beat (hours)</label>
					<input id="edit-game-ttb" name="time_to_beat_hours" type="number" step="0.5" min="0" />
				</div>
				<div class="field">
					<label for="edit-game-played">Played month</label>
					<input id="edit-game-played" name="played_month" type="month" />
				</div>
				<div class="actions">
					<button class="ghost danger small-button" data-action="delete-game" type="button">Delete game</button>
				</div>
				<p class="form-error hidden" id="game-modal-error" role="alert"></p>
				<footer>
					<button class="ghost" type="button" data-action="close-game">Cancel</button>
					<button class="cta" type="submit">Save</button>
				</footer>
			</form>
		</dialog>

		<dialog class="modal" id="poll-history-modal">
			<form class="modal-card poll-history-detail" method="dialog" novalidate>
				<header>
					<div>
						<h3 id="poll-history-title">Poll</h3>
						<p class="muted small" id="poll-history-meta"></p>
					</div>
					<button class="ghost icon-button" type="button" data-action="close-poll-history" aria-label="Close">
						×
					</button>
				</header>
				<p class="muted small" id="poll-history-summary"></p>
				<div class="poll-history-results" id="poll-history-results"></div>
				<div class="field">
					<label class="toggle-control" for="poll-history-validity">
						<span>Valid for lifetime points</span>
						<span class="toggle-switch">
							<input id="poll-history-validity" type="checkbox" />
							<span class="toggle-slider"></span>
						</span>
					</label>
				</div>
				<p class="form-error hidden" id="poll-history-error" role="alert"></p>
				<footer>
					<button class="ghost danger" type="button" data-action="delete-poll-history">Delete poll</button>
					<button class="ghost" type="button" data-action="close-poll-history">Close</button>
					<button class="cta" type="button" data-action="save-poll-history">Save validity</button>
				</footer>
			</form>
		</dialog>

		<script>
			const shell = document.querySelector(".admin-shell");
			const inviteForm = document.querySelector("#invite-modal .invite-form");
			const memberList = document.querySelector(".member-list");
			const gamesBody = document.querySelector(".games-editor-body");
			const pollHistoryBody = document.querySelector(".poll-history-body");
			const auditBody = document.querySelector(".audit-body");
			const gameModal = document.querySelector("#game-modal");
			const pollHistoryModal = document.querySelector("#poll-history-modal");
			const pollHistoryTitle = document.querySelector("#poll-history-title");
			const pollHistoryMeta = document.querySelector("#poll-history-meta");
			const pollHistorySummary = document.querySelector("#poll-history-summary");
			const pollHistoryResults = document.querySelector("#poll-history-results");
			const pollHistoryValidity = document.querySelector("#poll-history-validity");
			const pollHistoryError = document.querySelector("#poll-history-error");
			const gameModalTitle = document.querySelector("#game-modal-title");
			const gameModalSubtitle = document.querySelector("#game-modal-subtitle");
			const gameModalError = document.querySelector("#game-modal-error");
			const gameSubmitter = document.querySelector("#edit-game-submitter");
			const gameStatus = document.querySelector("#edit-game-status");
			const gameEligibility = document.querySelector("#edit-game-eligibility");
			const gameEligibilityHelp = document.querySelector("#edit-game-eligibility-help");
			const gameTags = document.querySelector("#edit-game-tags");
			const gameTtb = document.querySelector("#edit-game-ttb");
			const gamePlayed = document.querySelector("#edit-game-played");
			const gameSortHeaders = document.querySelectorAll(".games-editor-table th[data-sort]");
			const inviteModal = document.querySelector("#invite-modal");
			const memberModal = document.querySelector("#member-modal");
			const inviteError = document.querySelector("#invite-error");
			const memberModalError = document.querySelector("#member-modal-error");
			const memberName = document.querySelector("#member-name");
			const memberEmail = document.querySelector("#member-email");
			const editRole = document.querySelector("#edit-role");
			const editAlias = document.querySelector("#edit-alias");
			let activeMember = null;
			let activeGameId = null;
			let activePollHistoryId = null;
			let activePollHistoryValidity = false;
			let cachedMembers = [];
			let cachedGames = [];
			let cachedPollHistory = [];

			let currentUserEmail = null;

			fetch("/api/admin/summary")
				.then((response) => {
					if (response.status === 401) {
						window.location.href = "/api/auth/login";
						throw new Error("Unauthorized");
					}
					if (response.status === 403) {
						window.location.href = "/auth/denied";
						throw new Error("Forbidden");
					}
					return response.json();
				})
				.then((data) => {
					currentUserEmail = data?.me?.email || null;
					if (shell) shell.classList.remove("is-hidden");
					renderMembers(data?.members || []);
					loadGames();
					loadPollHistory();
					loadAuditLogs();
				})
				.catch(() => {});

			function renderMembers(members) {
				if (!memberList) return;
				if (!members || members.length === 0) {
					memberList.innerHTML = '<tr><td class="muted small" colspan="4">No members yet.</td></tr>';
					return;
				}

				cachedMembers = members;
				memberList.innerHTML = "";
				members.forEach((member) => {
					const row = document.createElement("tr");
					row.className = "clickable-row";
					row.dataset.email = member.email;

					const userCell = document.createElement("td");
					const userWrap = document.createElement("div");
					userWrap.className = "member-user";
					const avatar = document.createElement("div");
					avatar.className = "avatar";
					if (member.picture) {
						const img = document.createElement("img");
						img.className = "avatar-img";
						img.src = member.picture;
						img.alt = "";
						img.referrerPolicy = "no-referrer";
						img.decoding = "async";
						avatar.appendChild(img);
					} else {
						const fallback = document.createElement("span");
						fallback.className = "avatar-fallback";
						fallback.textContent = (member.name || member.email)
							.charAt(0)
							.toUpperCase();
						avatar.appendChild(fallback);
					}

						const name = document.createElement("div");
						name.className = "member-name";
						name.textContent = member.name || "—";
						if (member.active === 0) {
							const inactive = document.createElement("span");
							inactive.className = "member-status member-status-inactive";
							inactive.textContent = "Inactive";
							name.appendChild(document.createTextNode(" "));
							name.appendChild(inactive);
						}
						userWrap.appendChild(avatar);
						userWrap.appendChild(name);
						userCell.appendChild(userWrap);

					const aliasCell = document.createElement("td");
					aliasCell.textContent = member.alias || "—";

					const emailCell = document.createElement("td");
					emailCell.className = "member-email";
					emailCell.textContent = member.email;

					const roleCell = document.createElement("td");
					roleCell.textContent = member.role === "admin" ? "Admin" : "Member";

					row.appendChild(userCell);
					row.appendChild(aliasCell);
					row.appendChild(emailCell);
					row.appendChild(roleCell);
					memberList.appendChild(row);
				});
			}

			async function loadGames() {
				if (!gamesBody) return;
				gamesBody.innerHTML = '<tr><td class="muted small" colspan="7">Loading games…</td></tr>';
				const response = await fetch("/api/admin/games");
				if (!response.ok) {
					gamesBody.innerHTML = '<tr><td class="muted small" colspan="7">Unable to load games.</td></tr>';
					return;
				}
				const games = await response.json();
				cachedGames = games || [];
				renderGames(cachedGames);
			}

			async function loadPollHistory() {
				if (!pollHistoryBody) return;
				pollHistoryBody.innerHTML = '<tr><td class="muted small" colspan="4">Loading poll history…</td></tr>';
				const response = await fetch("/api/admin/polls");
				if (!response.ok) {
					pollHistoryBody.innerHTML = '<tr><td class="muted small" colspan="4">Unable to load poll history.</td></tr>';
					return;
				}
				const rows = await response.json();
				cachedPollHistory = rows || [];
				renderPollHistory(cachedPollHistory);
			}

			async function loadAuditLogs() {
				if (!auditBody) return;
				auditBody.innerHTML = '<tr><td class="muted small" colspan="4">Loading activity…</td></tr>';
				const response = await fetch("/api/admin/audit-logs");
				if (!response.ok) {
					auditBody.innerHTML = '<tr><td class="muted small" colspan="4">Unable to load audit logs.</td></tr>';
					return;
				}
				const logs = await response.json();
				renderAuditLogs(logs || []);
			}

			function formatPollDate(value) {
				if (!value) return "TBD";
				const normalized = value.includes("T") ? value : value.replace(" ", "T") + "Z";
				const parsed = new Date(normalized);
				if (Number.isNaN(parsed.getTime())) return value;
				return parsed.toLocaleDateString("en-US", {
					month: "short",
					day: "numeric",
					year: "numeric"
				});
			}

			function setPollHistoryError(message) {
				if (!pollHistoryError) return;
				if (message) {
					pollHistoryError.textContent = message;
					pollHistoryError.classList.remove("hidden");
				} else {
					pollHistoryError.textContent = "";
					pollHistoryError.classList.add("hidden");
				}
			}

			function renderPollHistory(rows) {
				if (!pollHistoryBody) return;
				if (!rows || rows.length === 0) {
					pollHistoryBody.innerHTML = '<tr><td class="muted small" colspan="4">No closed polls yet.</td></tr>';
					return;
				}
				pollHistoryBody.innerHTML = "";
				rows.forEach((row) => {
					const tr = document.createElement("tr");
					tr.className = "clickable-row poll-history-row";
					tr.dataset.pollId = String(row.id);

					const dateCell = document.createElement("td");
					dateCell.textContent = formatPollDate(row.closed_at || row.started_at);

					const winnerCell = document.createElement("td");
					winnerCell.textContent = row.winner_title || "—";

					const voterCell = document.createElement("td");
					voterCell.textContent = String(row.voter_count || 0);

					const validCell = document.createElement("td");
					validCell.textContent = row.history_valid ? "Valid" : "Invalid";

					tr.appendChild(dateCell);
					tr.appendChild(winnerCell);
					tr.appendChild(voterCell);
					tr.appendChild(validCell);
					pollHistoryBody.appendChild(tr);
				});
			}

			function renderAuditLogs(logs) {
				if (!auditBody) return;
				if (!logs || logs.length === 0) {
					auditBody.innerHTML = '<tr><td class="muted small" colspan="4">No audit activity yet.</td></tr>';
					return;
				}
				auditBody.innerHTML = "";
				logs.forEach((entry) => {
					const row = document.createElement("tr");

					const whenCell = document.createElement("td");
					whenCell.textContent = entry.created_at;

					const actorCell = document.createElement("td");
					actorCell.textContent = entry.actor_email;

					const actionCell = document.createElement("td");
					actionCell.textContent = entry.action;

					const entityCell = document.createElement("td");
					entityCell.textContent = entry.entity_id
						? `${entry.entity_type} #${entry.entity_id}`
						: entry.entity_type;

					row.appendChild(whenCell);
					row.appendChild(actorCell);
					row.appendChild(actionCell);
					row.appendChild(entityCell);
					auditBody.appendChild(row);
				});
			}

			function renderGames(games) {
				if (!gamesBody) return;
				if (!games || games.length === 0) {
					gamesBody.innerHTML = '<tr><td class="muted small" colspan="7">No games yet.</td></tr>';
					return;
				}
				gamesBody.innerHTML = "";
				games.forEach((game) => {
					const row = document.createElement("tr");
					const tags = parseTags(game.tags_json);
					row.dataset.id = game.id;
					row.dataset.title = game.title.toLowerCase();
					row.dataset.submitter = game.submitted_by_email || "";
					row.dataset.status = game.status || "";
					row.dataset.eligibility = game.poll_eligible === 1 ? "eligible" : "ineligible";
					row.dataset.tags = tags.join(", ");
					row.dataset.ttb = typeof game.time_to_beat_minutes === "number" ? String(game.time_to_beat_minutes) : "";
					row.dataset.played = game.played_month || "";
					row.className = "clickable-row";

					const titleCell = document.createElement("td");
					titleCell.textContent = game.title;

					const submitterCell = document.createElement("td");
					submitterCell.textContent = getMemberLabel(game.submitted_by_email);

					const statusCell = document.createElement("td");
					statusCell.textContent = game.status;

					const eligibilityCell = document.createElement("td");
					eligibilityCell.textContent = game.status === "backlog"
						? game.poll_eligible === 1
							? "Eligible"
							: "Ineligible"
						: "-";

					const tagsCell = document.createElement("td");
					tagsCell.textContent = tags.length > 0 ? tags.join(", ") : "-";

					const ttbCell = document.createElement("td");
					ttbCell.textContent = formatHours(game.time_to_beat_minutes);

					const playedCell = document.createElement("td");
					playedCell.textContent = game.played_month || "-";

					row.appendChild(titleCell);
					row.appendChild(submitterCell);
					row.appendChild(statusCell);
					row.appendChild(eligibilityCell);
					row.appendChild(tagsCell);
					row.appendChild(ttbCell);
					row.appendChild(playedCell);
					gamesBody.appendChild(row);
				});
				sortGameRows("title", "asc");
			}

			function getMemberLabel(email) {
				const match = cachedMembers.find((member) => member.email === email);
				if (!match) return email;
				return match.alias || match.name || match.email;
			}

			function parseTags(tagsJson) {
				if (!tagsJson) return [];
				try {
					const parsed = JSON.parse(tagsJson);
					return Array.isArray(parsed) ? parsed : [];
				} catch {
					return [];
				}
			}

			function formatHours(minutes) {
				if (typeof minutes !== "number") return "-";
				return (minutes / 60).toFixed(1);
			}

			if (gamesBody) {
				gamesBody.addEventListener("click", (event) => {
					const target = event.target;
					if (!(target instanceof HTMLElement)) return;
					const row = target.closest(".clickable-row");
					if (!row) return;
					const id = Number.parseInt(row.dataset.id || "", 10);
					const game = cachedGames.find((item) => item.id === id);
					if (!game) return;
					openGameModal(game);
				});
			}

			if (pollHistoryBody) {
				pollHistoryBody.addEventListener("click", (event) => {
					const target = event.target;
					if (!(target instanceof HTMLElement)) return;
					const row = target.closest(".poll-history-row");
					if (!(row instanceof HTMLElement)) return;
					const pollId = Number.parseInt(row.dataset.pollId || "", 10);
					if (Number.isNaN(pollId)) return;
					openPollHistoryModal(pollId);
				});
			}

			function renderPollHistoryResults(results) {
				if (!pollHistoryResults) return;
				pollHistoryResults.innerHTML = "";
				if (!Array.isArray(results) || results.length === 0) {
					const empty = document.createElement("p");
					empty.className = "muted small";
					empty.textContent = "No scored results for this poll.";
					pollHistoryResults.appendChild(empty);
					return;
				}
				const list = document.createElement("ol");
				list.className = "poll-results-list";
				results.forEach((result, index) => {
					const item = document.createElement("li");
					item.className = "poll-result";

					const title = document.createElement("span");
					title.className = "poll-result-title";
					title.textContent = `${index + 1}. ${result.title}`;

					const points = document.createElement("span");
					points.className = "poll-result-points";
					points.textContent = `${result.points ?? 0} pts`;

					item.appendChild(title);
					item.appendChild(points);
					list.appendChild(item);
				});
				pollHistoryResults.appendChild(list);
			}

			async function openPollHistoryModal(pollId) {
				if (!pollHistoryModal) return;
				activePollHistoryId = pollId;
				activePollHistoryValidity = false;
				setPollHistoryError("");
				if (pollHistoryTitle) pollHistoryTitle.textContent = `Poll #${pollId}`;
				if (pollHistoryMeta) pollHistoryMeta.textContent = "Loading poll details…";
				if (pollHistorySummary) pollHistorySummary.textContent = "";
				if (pollHistoryResults) {
					pollHistoryResults.innerHTML = '<p class="muted small">Loading results…</p>';
				}
				if (pollHistoryValidity instanceof HTMLInputElement) {
					pollHistoryValidity.checked = false;
					pollHistoryValidity.disabled = true;
				}
				pollHistoryModal.showModal();

				const response = await fetch(`/api/admin/polls?id=${encodeURIComponent(String(pollId))}`);
				if (!response.ok) {
					const message = await response.text();
					setPollHistoryError(message || "Unable to load poll details.");
					if (pollHistoryMeta) pollHistoryMeta.textContent = "";
					if (pollHistoryResults) pollHistoryResults.innerHTML = "";
					return;
				}

				const payload = await response.json();
				const poll = payload?.poll;
				const results = payload?.results || [];
				if (!poll) {
					setPollHistoryError("Unable to load poll details.");
					return;
				}

				activePollHistoryValidity = Boolean(poll.history_valid);
				if (pollHistoryTitle) pollHistoryTitle.textContent = `Poll #${poll.id}`;
				if (pollHistoryMeta) {
					pollHistoryMeta.textContent = `Closed ${formatPollDate(poll.closed_at || poll.started_at)}`;
				}
				if (pollHistorySummary) {
					pollHistorySummary.textContent =
						`Winner: ${poll.winner_title || "—"} · Unique voters: ${poll.voter_count || 0}`;
				}
				if (pollHistoryValidity instanceof HTMLInputElement) {
					pollHistoryValidity.disabled = false;
					pollHistoryValidity.checked = activePollHistoryValidity;
				}
				renderPollHistoryResults(results);
			}

			async function savePollHistoryValidity() {
				if (!activePollHistoryId || !(pollHistoryValidity instanceof HTMLInputElement)) return;
				const nextValidity = pollHistoryValidity.checked;
				const response = await fetch("/api/admin/polls", {
					method: "PATCH",
					headers: { "Content-Type": "application/json" },
					body: JSON.stringify({ id: activePollHistoryId, history_valid: nextValidity })
				});
				if (response.ok) {
					activePollHistoryValidity = nextValidity;
					setPollHistoryError("");
					loadPollHistory();
					return;
				}
				const message = await response.text();
				setPollHistoryError(message || "Unable to save poll validity.");
				pollHistoryValidity.checked = activePollHistoryValidity;
			}

			async function deletePollHistory() {
				if (!activePollHistoryId) return;
				const confirmed = window.confirm("Delete this poll history entry? This cannot be undone.");
				if (!confirmed) return;
				const response = await fetch("/api/admin/polls", {
					method: "DELETE",
					headers: { "Content-Type": "application/json" },
					body: JSON.stringify({ id: activePollHistoryId })
				});
				if (response.ok) {
					setPollHistoryError("");
					pollHistoryModal?.close();
					loadPollHistory();
					return;
				}
				const message = await response.text();
				setPollHistoryError(message || "Unable to delete poll history entry.");
			}

			function syncGameEligibilityControl() {
				if (!gameStatus || !gameEligibility) return;
				const isBacklog = gameStatus.value === "backlog";
				gameEligibility.disabled = !isBacklog;
				if (!isBacklog) {
					gameEligibility.checked = false;
				}
				if (gameEligibilityHelp) {
					gameEligibilityHelp.textContent = isBacklog
						? "Select up to 2 backlog games per member."
						: "Only backlog games can be poll eligible.";
				}
			}

			if (gameStatus) {
				gameStatus.addEventListener("change", () => {
					syncGameEligibilityControl();
				});
			}

			function openGameModal(game) {
				if (!gameModal || !gameSubmitter || !gameStatus || !gameEligibility || !gameTags || !gameTtb || !gamePlayed) {
					return;
				}
				activeGameId = game.id;
				gameModalTitle.textContent = game.title;
				gameModalSubtitle.textContent = game.submitted_by_email;
				gameSubmitter.innerHTML = "";
				cachedMembers.forEach((member) => {
					const option = document.createElement("option");
					option.value = member.email;
					option.textContent = member.alias || member.name || member.email;
					if (member.email === game.submitted_by_email) option.selected = true;
					gameSubmitter.appendChild(option);
				});
				gameStatus.value = game.status;
				gameEligibility.checked = game.status === "backlog" && game.poll_eligible === 1;
				syncGameEligibilityControl();
				gameTags.value = parseTags(game.tags_json).join(", ");
				gameTtb.value = typeof game.time_to_beat_minutes === "number"
					? String((game.time_to_beat_minutes / 60).toFixed(1))
					: "";
				gamePlayed.value = game.played_month || "";
				gameModalError.classList.add("hidden");
				gameModalError.textContent = "";
				gameModal.showModal();
			}

			if (gameModal) {
				gameModal.addEventListener("click", (event) => {
					const target = event.target;
					if (!(target instanceof HTMLElement)) return;
					if (target.closest("[data-action='close-game']")) {
						gameModal.close();
					}
						if (target.closest("[data-action='delete-game']")) {
							if (!activeGameId) return;
							const confirmed = window.confirm("Delete this game? This cannot be undone.");
							if (!confirmed) return;
							fetch("/api/admin/games", {
							method: "DELETE",
							headers: { "Content-Type": "application/json" },
							body: JSON.stringify({ id: activeGameId })
							}).then((response) => {
								if (response.ok) {
									gameModal.close();
									loadGames();
								} else {
									response
										.text()
										.then((message) => {
											gameModalError.textContent = message || "Unable to delete game.";
											gameModalError.classList.remove("hidden");
										})
										.catch(() => {
											gameModalError.textContent = "Unable to delete game.";
											gameModalError.classList.remove("hidden");
										});
								}
							});
						}
				});
				gameModal.addEventListener("submit", async (event) => {
					event.preventDefault();
					if (!activeGameId) return;
					const hoursValue = gameTtb.value ? Number.parseFloat(gameTtb.value) : null;
					if (hoursValue !== null && Number.isNaN(hoursValue)) {
						gameModalError.textContent = "Time to beat must be a number.";
						gameModalError.classList.remove("hidden");
						return;
					}
					if (!gameSubmitter.value) {
						gameModalError.textContent = "Submitter is required.";
						gameModalError.classList.remove("hidden");
						return;
					}
					const playedMonthValue = gamePlayed.value.trim();
					if (playedMonthValue && !/^\d{4}-\d{2}$/.test(playedMonthValue)) {
						gameModalError.textContent = "Played month must be YYYY-MM.";
						gameModalError.classList.remove("hidden");
						return;
					}
					const payload = {
						id: activeGameId,
						submitted_by_email: gameSubmitter.value,
						status: gameStatus.value,
						tags: gameTags.value,
						time_to_beat_hours: hoursValue,
						played_month: gamePlayed.value
					};
					if (gameStatus.value === "backlog" && gameEligibility) {
						payload.poll_eligible = gameEligibility.checked;
					}
					const response = await fetch("/api/admin/games", {
						method: "PATCH",
						headers: { "Content-Type": "application/json" },
						body: JSON.stringify(payload)
					});
						if (response.ok) {
							gameModal.close();
							loadGames();
						} else {
							const message = await response.text();
							gameModalError.textContent = message || "Unable to update game.";
							gameModalError.classList.remove("hidden");
						}
					});
				}

			function getSortValue(row, key) {
				if (key === "title") return row.dataset.title || "";
				if (key === "submitter") return row.dataset.submitter || "";
				if (key === "status") return row.dataset.status || "";
				if (key === "eligibility") return row.dataset.eligibility || "";
				if (key === "tags") return row.dataset.tags || "";
				if (key === "ttb") return Number.parseInt(row.dataset.ttb || "0", 10);
				if (key === "played") return row.dataset.played || "";
				return "";
			}

			function sortGameRows(key, direction) {
				if (!gamesBody) return;
				const rows = Array.from(gamesBody.querySelectorAll(".clickable-row"));
				const dir = direction === "desc" ? -1 : 1;
				const sorted = rows.sort((a, b) => {
					const aValue = getSortValue(a, key);
					const bValue = getSortValue(b, key);
					if (typeof aValue === "number" && typeof bValue === "number") {
						const aScore = aValue || Number.MAX_SAFE_INTEGER;
						const bScore = bValue || Number.MAX_SAFE_INTEGER;
						return (aScore - bScore) * dir;
					}
					return String(aValue).localeCompare(String(bValue)) * dir;
				});
				sorted.forEach((row) => gamesBody.appendChild(row));
			}

			gameSortHeaders.forEach((header) => {
				header.addEventListener("click", () => {
					const key = header.dataset.sort;
					if (!key) return;
					const current = header.dataset.direction || "asc";
					const nextDirection = current === "asc" ? "desc" : "asc";
					gameSortHeaders.forEach((th) => {
						delete th.dataset.direction;
					});
					header.dataset.direction = nextDirection;
					sortGameRows(key, nextDirection);
				});
			});

			document.addEventListener("click", (event) => {
				const target = event.target;
				if (!(target instanceof HTMLElement)) return;
				const openInvite = target.closest("[data-action='open-invite']");
				if (openInvite && inviteModal) {
					if (inviteError) {
						inviteError.textContent = "";
						inviteError.classList.add("hidden");
					}
					inviteModal.showModal();
				}
				const closeInvite = target.closest("[data-action='close-invite']");
				if (closeInvite && inviteModal) {
					if (inviteError) {
						inviteError.textContent = "";
						inviteError.classList.add("hidden");
					}
					inviteModal.close();
				}
				const closeMember = target.closest("[data-action='close-member']");
				if (closeMember && memberModal) {
					if (memberModalError) {
						memberModalError.textContent = "";
						memberModalError.classList.add("hidden");
					}
					memberModal.close();
				}
				const closePollHistory = target.closest("[data-action='close-poll-history']");
				if (closePollHistory && pollHistoryModal) {
					setPollHistoryError("");
					pollHistoryModal.close();
				}
				const row = target.closest("tr[data-email]");
				if (row && memberModal) {
					const email = row.dataset.email;
					if (!email) return;
					openMemberModal(email);
				}
			});

			if (inviteForm) {
				inviteForm.addEventListener("submit", async (event) => {
					event.preventDefault();
					if (inviteError) {
						inviteError.textContent = "";
						inviteError.classList.add("hidden");
					}
					const formData = new FormData(inviteForm);
					const email = formData.get("email");
					const role = formData.get("role");
					const response = await fetch("/api/admin/members", {
						method: "POST",
						headers: { "Content-Type": "application/json" },
						body: JSON.stringify({ email, role })
					});
					if (response.ok) {
						inviteForm.reset();
						if (inviteModal) inviteModal.close();
						loadMembers();
					} else if (inviteError) {
						const message = await response.text();
						inviteError.textContent = message || "Unable to add member.";
						inviteError.classList.remove("hidden");
					}
				});
			}

			async function loadMembers() {
				if (!memberList) return;
				memberList.innerHTML = '<tr><td class="muted small" colspan="4">Loading members…</td></tr>';
				const response = await fetch("/api/admin/members");
				if (!response.ok) {
					memberList.innerHTML = '<tr><td class="muted small" colspan="4">Unable to load members.</td></tr>';
					return;
				}
				const members = await response.json();
				renderMembers(members);
			}

			function openMemberModal(email) {
				activeMember = email;
				const row = document.querySelector(`tr[data-email="${email}"]`);
				if (!row || !memberModal) return;
				if (memberModalError) {
					memberModalError.textContent = "";
					memberModalError.classList.add("hidden");
				}
				const name = row.querySelector(".member-name")?.textContent || "Member";
				if (memberName) memberName.textContent = name;
				if (memberEmail) memberEmail.textContent = email;
				memberModal.showModal();
				loadMemberDetail(email);
			}

			async function loadMemberDetail(email) {
				const member = cachedMembers.find((item) => item.email === email);
				if (!member) return;
				if (editRole) editRole.value = member.role;
				if (editAlias) editAlias.value = member.alias || "";
				const isSelf = currentUserEmail && member.email === currentUserEmail;
				if (editRole) editRole.disabled = isSelf;
				const deleteButton = memberModal?.querySelector("[data-action='delete']");
				if (deleteButton) deleteButton.disabled = isSelf;
			}

			if (memberModal) {
				memberModal.addEventListener("submit", async (event) => {
					event.preventDefault();
					if (!activeMember) return;
					if (memberModalError) {
						memberModalError.textContent = "";
						memberModalError.classList.add("hidden");
					}
					const isSelf = currentUserEmail && activeMember === currentUserEmail;
					const payload = {
						email: activeMember,
						alias: editAlias?.value || ""
					};
					if (!isSelf) {
						payload.role = editRole?.value || "member";
					}
					const response = await fetch("/api/admin/members", {
						method: "PATCH",
						headers: { "Content-Type": "application/json" },
						body: JSON.stringify(payload)
					});
					if (response.ok) {
						memberModal.close();
						loadMembers();
					} else if (memberModalError) {
						const message = await response.text();
						memberModalError.textContent = message || "Unable to update member.";
						memberModalError.classList.remove("hidden");
					}
				});

				memberModal.addEventListener("click", async (event) => {
					const target = event.target;
					if (!(target instanceof HTMLElement)) return;
					const action = target.dataset.action;
					if (action === "delete" && activeMember) {
						const confirmed = window.confirm("Delete this member? This cannot be undone.");
						if (!confirmed) return;
						if (memberModalError) {
							memberModalError.textContent = "";
							memberModalError.classList.add("hidden");
						}
						const response = await fetch("/api/admin/members", {
							method: "DELETE",
							headers: { "Content-Type": "application/json" },
							body: JSON.stringify({ email: activeMember })
						});
							if (response.ok) {
								memberModal.close();
								loadMembers();
							} else if (memberModalError) {
								const message = await response.text();
								memberModalError.textContent = message || "Unable to delete member.";
								memberModalError.classList.remove("hidden");
								if (response.status === 409) {
									loadMembers();
								}
							}
						}
					});
				}

			if (pollHistoryModal) {
				pollHistoryModal.addEventListener("click", async (event) => {
					const target = event.target;
					if (!(target instanceof HTMLElement)) return;
					if (target.closest("[data-action='save-poll-history']")) {
						await savePollHistoryValidity();
					}
					if (target.closest("[data-action='delete-poll-history']")) {
						await deletePollHistory();
					}
				});
				pollHistoryModal.addEventListener("close", () => {
					activePollHistoryId = null;
					activePollHistoryValidity = false;
					setPollHistoryError("");
				});
			}

		</script>
	</body>
</html>

<style>
	main {
		display: grid;
		gap: 2rem;
	}

	.hero {
		display: grid;
		gap: 0;
		max-width: 520px;
	}

	.hero .muted {
		max-width: 34rem;
	}

	.members-card {
		max-width: 600px;
	}

	.invite-form {
		display: grid;
		gap: 1rem;
	}

	.member-name {
		font-weight: 600;
	}

	.member-status {
		display: inline-flex;
		align-items: center;
		padding: 0.08rem 0.38rem;
		border-radius: 999px;
		font-size: 0.66rem;
		font-weight: 600;
		text-transform: uppercase;
		letter-spacing: 0.04em;
	}

	.member-status-inactive {
		background: rgba(140, 90, 90, 0.14);
		color: #8a2f2f;
		border: 1px solid rgba(140, 90, 90, 0.28);
	}

	.member-email {
		color: var(--muted);
		font-size: 0.82rem;
	}

	.small-button {
		padding: 0.4rem 0.7rem;
		font-size: 0.75rem;
	}

	.ghost.danger {
		border-color: rgba(200, 90, 90, 0.5);
		color: #8a2f2f;
	}

	.invite-cta {
		width: fit-content;
	}

	@media (max-width: 900px) {
		.invite-form {
			grid-template-columns: 1fr;
		}

		.actions {
			flex-direction: column;
			align-items: flex-start;
		}
	}

	.is-hidden {
		display: none;
	}

</style>
